<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MarkDownPlug]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F26%2FMarkDownPlug%2F</url>
    <content type="text"><![CDATA[This is a group demo!]]></content>
      <categories>
        <category>MarkDownPlug</category>
      </categories>
      <tags>
        <tag>MarkDownPlug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm&github]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F25%2Fnpm%26github%2F</url>
    <content type="text"><![CDATA[npm全称Node Package Manager，是node.js的模块依赖管理工具，主要应用与web前端。由于npm的源在国外，速度慢or无法安装，国内优秀的npm镜像资源可以选择使用。 国内优秀npm镜像淘宝npm镜像 搜索地址：http://npm.taobao.org/ registry地址：http://registry.npm.taobao.org/ cnpmjs镜像 搜索地址：http://cnpmjs.org/ registry地址：http://r.cnpmjs.org/ 如何使用有很多方法来配置npm的registry地址，下面根据不同情境列出几种比较常用的方法。以淘宝npm镜像举例： 临时使用npm –registry https://registry.npm.taobao.org install express 持久使用-修改地址. Git输入：npm config set registry https://registry.npm.taobao.org 文本直接编辑：registry=https://registry.npm.taobao.org 偏好使用 1npm i(nstall) (sourcepackage eg:) hexo-generator-archive --save-dev --registry=https://registry.npm.taobao.org 配置后验证是配置否成功. Git输入： npm config get registry Git输入： npm info express 通过cnpm使用 Git输入：npm install -g cnpm –registry=https://registry.npm.taobao.org Git输入：cnpm install express]]></content>
      <categories>
        <category>GitHub&amp;走过的坑</category>
      </categories>
      <tags>
        <tag>npm 镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载器&反射&代理]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F17%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%26%E5%8F%8D%E5%B0%84%26%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[类加载&amp;类加载器类的加载描述: 反射&amp;reflectJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象。 Class类的获取 123456789101112131415161718/*for example*/public class TestClass &#123; public static void main(String[] args) throws ClassNotFoundException &#123; /* 类的三种获取方式 */ /* the first... */ Person p = new Person(); Class pClass = p.getClass(); System.out.println(pClass); /* the second... */ Class sClass = Person.class; System.out.println(sClass); /* the third... */ Class tClass = Class.forName(&quot;ReflectionTools.Person&quot;); System.out.println(tClass); &#125;&#125; Class类构造方法的获取 123456789101112/*for example*//* 仅仅显示由public修饰的构造方法 */ Constructor[] con = tClass.getConstructors(); for (Object obj : con) System.out.println(obj); Constructor[] conAll = tClass.getDeclaredConstructors(); System.out.println(&quot;------- this is a dividing line --------&quot;);/* 所有的构造方法都显示出来. */ for (Object obj : conAll) System.out.println(obj); System.out.println(&quot;------- this is a dividing line --------&quot;); Class类字段的获取 12/*for example*/与构造方法完全一样，用Field替换对应的部分即可。 Class类成员方法的获取 123/*for example*/不同之处在于getMethods方法获取的是获取的所有方法，包括父类的的public修饰的。getDeclaredMethods是自己的所有修饰符修饰的成员方法。 使用带Declared的函数获取的函数是完整的，但是若需要使用指定的成员变量与成员方法，则可以利用反射。使用对应的带参数的函数+函数名称即可调用，若是非公有的，可以使用setAccessiable強制調用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/*for example 非局部的使用*//*PJO定义一个简单的类*/package ReflectionTools;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;class Person &#123; private String name; private int age; private String address; /* 私有的带参构造方法。 */ private Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name) &#123; this.name = name; &#125; public Person(String name, int age, String address) &#123; super(); this.name = name; this.age = age; this.address = address; &#125; /* 无参构造方法. */ Person() &#123; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; private void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &quot;]&quot;; &#125;&#125;/*测试主函数*/public class TestClass &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123; /* 类的三种获取方式 */ /* the first... */ Person p = new Person(); Class pClass = p.getClass(); System.out.println(pClass); /* the second... */ Class sClass = Person.class; System.out.println(sClass); /* the third... */ Class tClass = Class.forName(&quot;ReflectionTools.Person&quot;); System.out.println(tClass); System.out.println(&quot;-------this is a dividing line--------&quot;); /* 仅仅显示由public修饰的构造方法 */ Constructor[] con = tClass.getConstructors(); for (Object obj : con) System.out.println(obj); Constructor[] conAll = tClass.getDeclaredConstructors(); System.out.println(&quot;------- this is a dividing line --------&quot;); /* 所有的构造方法都显示出来. */ for (Object obj : conAll) System.out.println(obj); System.out.println(&quot;------- this is a dividing line --------&quot;); /* 无参数构造方法的使用。 */ Constructor conSpecific = tClass.getDeclaredConstructor(); Object obj = conSpecific.newInstance(); /*调用private修饰的变量*/ Field fieldSpecific = tClass.getDeclaredField(&quot;name&quot;); fieldSpecific.setAccessible(true); fieldSpecific.set(obj, &quot;Tom&quot;); /* 调用非public修饰的成员方法 */ Method methodSpecific = tClass.getDeclaredMethod(&quot;setAge&quot;, int.class); methodSpecific.setAccessible(true); methodSpecific.invoke(obj, 5); System.out.println(obj); &#125;&#125;/*控制台输出结果为：*/ class ReflectionTools.Person class ReflectionTools.Person class ReflectionTools.Person -------this is a dividing line-------- public ReflectionTools.Person(java.lang.String,int,java.lang.String) public ReflectionTools.Person(java.lang.String) ------- this is a dividing line -------- private ReflectionTools.Person(java.lang.String,int) ReflectionTools.Person() public ReflectionTools.Person(java.lang.String,int,java.lang.String) public ReflectionTools.Person(java.lang.String) ------- this is a dividing line -------- Person [name=Tom, age=5, address=null] 反射的应用 构造一个动态的对象调用动态的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*for example*//**config.ini是配置class类和对应方法的。/package ReflectionTools;import java.io.FileReader;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;/*config.ini*/ /*content: className = ReflectionTools.personTest classValue = hobby */class animal &#123; private String name; public animal() &#123; &#125; public void show() &#123; System.out.println(this.name + &quot;this is animailShow!&quot;); &#125;&#125;class personTest &#123; private String name; private int age; private String address; public personTest() &#123; &#125; public void hobby() &#123; System.out.println(this.name + &quot;this is a personHobby!&quot; + this.age + this.address); &#125;&#125;public class ReflectionApp &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException &#123; /* 使用throws不必初始化，直接异常弹出，这样的目的是为了防止空指针异常。 */ FileReader fileReader = new FileReader(&quot;config.ini&quot;); Properties keyValue = new Properties(); keyValue.load(fileReader); fileReader.close(); String getNameID = keyValue.getProperty(&quot;className&quot;); String getValueID = keyValue.getProperty(&quot;classValue&quot;); Class classFiles = Class.forName(getNameID); Constructor con = classFiles.getConstructor(); Object obj = con.newInstance(); Method meTest = classFiles.getDeclaredMethod(getValueID); meTest.invoke(obj); &#125;&#125; 反射修改泛型 1234567891011121314151617181920212223import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;/* * 我给你ArrayList&lt;Integer&gt;的一个对象，要求在这个集合中添加一个字符串数据。 */public class ArrayLis&#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; /*创建集合对象*/ ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); Class classfile = array.getClass(); /*集合ArrayList的class文件对象*/ Method me = classfile.getMethod(&quot;add&quot;, Object.class); me.invoke(array, &quot;hello&quot;); /*调用array的add方法，传入的值是hello.*/ me.invoke(array, &quot;world&quot;); System.out.println(array); &#125; &#125; Proxy代理对象 描述：代理一个对象的操作，结合InvocationHandler接口，只能实现对接口的代理。若要对类进行代理需要使用cglib。 tip：该类代理不会再框架中使用，故而略…]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>定时器 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InetAddress]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F16%2FInetAddress%2F</url>
    <content type="text"><![CDATA[InetAddress此类表示Internet协议（IP）地址。 IP地址是由IP使用的32位或128位无符号数字，构建UDP和TCP协议的低级协议。 IP地址结构由定义RFC 790: Assigned Numbers ， RFC 1918: Address Allocation for Private Internets ， RFC 2365: Administratively Scoped IP Multicast和RFC 2373: IP Version 6 Addressing Architecture 。 InetAddress的一个实例由一个IP地址和可能的相应主机名组成（取决于它是用主机名构造还是已经完成了反向主机名解析）。 该类的使用主要是借助API查看对应的常用函数 主机ip常用InetAddress. Code eg： 1234567891011121314151617181920212223242526package NormalFunction;import java.net.InetAddress;import java.net.UnknownHostException;public class TestFuntion &#123; /** * @param args * @throws UnknownHostException */ public static void main(String[] args) throws UnknownHostException &#123; /* 静态方法对象-getAllByName&amp;getByName. */ InetAddress address = InetAddress.getByName(&quot;192.168.0.168&quot;); /*获取主机名字*/ String hostName = address.getHostName(); /*获取主机ip*/ String ip = address.getHostAddress(); System.out.println(hostName + &quot;----&quot; + ip); &#125;&#125; UDP数据报的获取&amp;接收 此类表示用于发送和接收数据报数据包的套接字。 数据报套接字是分组传送服务的发送或接收点。 在数据报套接字上发送或接收的每个数据包都被单独寻址和路由。 从一个机器发送到另一个机器的多个分组可以不同地路由，并且可以以任何顺序到达。 Send&amp;Receive Code eg： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/*for example*//*发送端与接收端对不能写在一个Java类文件里面DatagramSocket.receive是阻塞式.*//*接收端*/package NormalFunction;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class TestReceived &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub /* 创建接收端套接字. */ DatagramSocket rdgs = new DatagramSocket(15000); byte[] rbuffer = new byte[1024]; int rlength = rbuffer.length; DatagramPacket rdgp = new DatagramPacket(rbuffer, rlength); rdgs.receive(rdgp); InetAddress raddress = rdgp.getAddress(); String ipName = raddress.getHostName();/* 获取发送端主机名. */ String ipX = raddress.getHostAddress(); /* 获取发送端IP地址. */ /* 接收端解析并且显示在控制台. */ byte[] Consolebuffer = rdgp.getData(); int Consolelength = Consolebuffer.length; // String ConsoleString = new String(Consolebuffer); String ConsoleString = new String(Consolebuffer, 0, Consolelength); System.out.println(&quot;ReceivedFromName:&quot; + ipName + &quot; ip:&quot; + ipX + &quot; Content:&quot; + ConsoleString); rdgs.close(); &#125; &#125;/*发送端*/package NormalFunction;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class TestSend &#123; public static void main(String[] args) throws IOException &#123; /* 创建套接字对象-发送端 */ DatagramSocket dgs = new DatagramSocket(); byte[] sendbys = &quot;thisTestSenderData!&quot;.getBytes(); int sendlength = sendbys.length; InetAddress address = InetAddress.getByName(&quot;192.168.0.168&quot;); int port = 15000; DatagramPacket senddgs = new DatagramPacket(sendbys, sendlength, address, port); dgs.send(senddgs); dgs.close(); &#125;&#125;/*combine_files*/package NormalFunction;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;public class Sender_Receive &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub // TODO Auto-generated method stub /* 创建接收端套接字. */ DatagramSocket rdgs = null; try &#123; rdgs = new DatagramSocket(15000); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; byte[] rbuffer = new byte[1024]; int rlength = rbuffer.length; DatagramPacket rdgp = new DatagramPacket(rbuffer, rlength); try &#123; rdgs.receive(rdgp); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; InetAddress raddress = rdgp.getAddress(); String ipName = raddress.getHostName();/* 获取发送端主机名. */ String ipX = raddress.getHostAddress(); /* 获取发送端IP地址. */ /* 接收端解析并且显示在控制台. */ byte[] Consolebuffer = rdgp.getData(); int Consolelength = Consolebuffer.length; // String ConsoleString = new String(Consolebuffer); String ConsoleString = new String(Consolebuffer, 0, Consolelength); System.out.println(&quot;ReceivedFromName:&quot; + ipName + &quot; ip:&quot; + ipX + &quot; Content:&quot; + ConsoleString); rdgs.close(); System.out.println(&quot;this is a deviding line!&quot;); /* 创建套接字对象-发送端 */ DatagramSocket dgs = new DatagramSocket(); byte[] sendbys = &quot;thisTestSenderData!&quot;.getBytes(); int sendlength = sendbys.length; InetAddress address = InetAddress.getByName(&quot;192.168.0.168&quot;); int port = 15000; DatagramPacket senddgs = new DatagramPacket(sendbys, sendlength, address, port); dgs.send(senddgs); dgs.close(); &#125; &#125; 数据发送=&gt;聊天窗口 将上述的单条数据发送改为由键盘输入的发送，并且接收，用多线程实现，不使用多线程为上代码问题。。 UDP:Code eg-runable实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/*实现runble接口实现方式.*/package NormalFunction;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;class sender implements Runnable &#123; private DatagramSocket sd_sender; public sender(DatagramSocket sd_sender) &#123; this.sd_sender = sd_sender; &#125; @Override public void run() &#123; try &#123; /* 键盘获取数据. */ BufferedReader br = new BufferedReader(new InputStreamReader( System.in)); String line = null; while ((line = br.readLine()) != null) &#123; if (&quot;over!&quot;.equals(line)) &#123; break; &#125; /* 数据打包并且发送. */ byte[] bys = line.getBytes(); DatagramPacket dp_sender = new DatagramPacket(bys, bys.length, InetAddress.getByName(&quot;192.168.0.255&quot;), 15360); sd_sender.send(dp_sender); &#125; sd_sender.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class receiver implements Runnable &#123; private DatagramSocket ds_receiver; public receiver(DatagramSocket ds_receiver) &#123; this.ds_receiver = ds_receiver; &#125; @Override public void run() &#123; try &#123; while (true) &#123; byte[] bys = new byte[1024]; DatagramPacket dp_receiver = new DatagramPacket(bys, bys.length); ds_receiver.receive(dp_receiver); /* parseData */ String ip = dp_receiver.getAddress().getHostAddress(); String s = new String(dp_receiver.getData(), 0, dp_receiver.getLength()); System.out.println(&quot;from &quot; + ip + &quot; data is : &quot; + s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class MultiThreadSend_Receive &#123; public static void main(String[] args) throws SocketException &#123; DatagramSocket ds_client = new DatagramSocket(); DatagramSocket ds_receiver = new DatagramSocket(15360); sender sender_client = new sender(ds_client); receiver receiver_client = new receiver(ds_receiver); Thread thread_client = new Thread(sender_client); Thread thread_receive = new Thread(receiver_client); thread_client.start(); thread_receive.start(); &#125;&#125; UDP:Code eg-extends实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package NormalFunction;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import com.sun.webkit.ThemeClient;class sender extends Thread &#123; private DatagramSocket sd_sender; public sender(DatagramSocket sd_sender) &#123; this.sd_sender = sd_sender; &#125; @Override public void run() &#123; try &#123; /* 键盘获取数据. */ BufferedReader br = new BufferedReader(new InputStreamReader( System.in)); String line = null; while ((line = br.readLine()) != null) &#123; if (&quot;over!&quot;.equals(line)) &#123; break; &#125; /* 数据打包并且发送至广播域. */ byte[] bys = line.getBytes(); DatagramPacket dp_sender = new DatagramPacket(bys, bys.length, InetAddress.getByName(&quot;192.168.0.255&quot;), 15360); sd_sender.send(dp_sender); &#125; sd_sender.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class receiver extends Thread &#123; private DatagramSocket ds_receiver; public receiver(DatagramSocket ds_receiver) &#123; this.ds_receiver = ds_receiver; &#125; @Override public void run() &#123; try &#123; while (true) &#123; byte[] bys = new byte[1024]; DatagramPacket dp_receiver = new DatagramPacket(bys, bys.length); ds_receiver.receive(dp_receiver); /* parseData */ String ip = dp_receiver.getAddress().getHostAddress(); String s = new String(dp_receiver.getData(), 0, dp_receiver.getLength()); System.out.println(&quot;from &quot; + ip + &quot; data is : &quot; + s); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class MultiThreadSend_Receive &#123; public static void main(String[] args) throws SocketException &#123; DatagramSocket ds_client = new DatagramSocket(); DatagramSocket ds_receiver = new DatagramSocket(15360); sender sender_client = new sender(ds_client); receiver receiver_client = new receiver(ds_receiver); sender_client.start(); receiver_client.start(); &#125;&#125; TCP实现的数据传送 UDP数据包是非连接方式传播的，也就是说只保证自己的数据在网内广播，不是针对性的链接，同时也不保证数据被指定的机器接收到，TCP是连接式连接的，保证数据的传送，但是效率偏低，同样UDP也存在着一个问题就是容易产生垃圾广播数据，尤其是在非令牌环路广播域中，产生大量垃圾数据，造成网络速度迟缓。 TCP：Code实现单条数据的传输与发送. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*for example*//*数据发送端*/package CompareTool;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;import java.net.UnknownHostException;public class TCP_Client &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; Socket clientSocket = new Socket(&quot;192.168.119.9&quot;, 15360); OutputStream clientStream = clientSocket.getOutputStream(); clientStream.write(&quot;thisSenderData!&quot;.getBytes()); clientSocket.close(); &#125;&#125;/*数据服务器端*/package CompareTool;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class TCP_Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(15360); Socket nextSocket = serverSocket.accept(); byte[] bysServer = new byte[1024]; InputStream ServerStream = nextSocket.getInputStream(); int serverLength = ServerStream.read(bysServer); String getString = new String(bysServer, 0, serverLength); System.out.println(&quot;ReceivedData:&quot; + getString); serverSocket.close(); &#125;&#125;/*服务器端实现方式二：*/package CompareTool;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class TCP_Server &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(15360); Socket nextSocket = serverSocket.accept(); BufferedReader serverReader = new BufferedReader(new InputStreamReader( nextSocket.getInputStream())); String lineServer = null; while ((lineServer = serverReader.readLine()) != null) &#123; System.out.println(&quot;ReceivedData:&quot; + lineServer); &#125; serverSocket.close(); &#125;&#125; TCP：Code实现的由键盘输入实现和数据发送-控制台显示. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*客户端*/package ImproveTCP;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class ClientPort &#123; public static void main(String[] args) throws IOException &#123; /* 创建套接字对象 */ Socket clientSocket = new Socket(&quot;192.168.119.9&quot;, 15360); /*输入输出流的定义.*/ BufferedReader clientReader = new BufferedReader(new InputStreamReader( System.in)); /*从键盘获取流，因此是reader.*/ BufferedWriter clientWrite = new BufferedWriter(new OutputStreamWriter( clientSocket.getOutputStream())); /*将套接字的数据流暴露出来，进行写入，发送。*/ String clientString = null; /*每一行输出一次，遇到over!终止发送数据.*/ while((clientString = clientReader.readLine())!= null)&#123; if (&quot;over!&quot;.equals(clientString)) &#123; break; &#125; clientWrite.write(clientString); clientWrite.newLine(); clientWrite.flush(); &#125; clientSocket.close(); &#125; &#125;/*服务器端*/package ImproveTCP;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerPort &#123; public static void main(String[] args) throws IOException &#123; ServerSocket serverSocket = new ServerSocket(15360); /* 收到数据需要提示发送端，当前已收到数据 */ Socket nextSocket = serverSocket.accept(); String serverString = null; BufferedReader serverReader = new BufferedReader(new InputStreamReader( nextSocket.getInputStream())); while ((serverString = serverReader.readLine()) != null) &#123; System.out.println(&quot;ServerPort: current receivedData:&quot; + serverString); &#125; serverSocket.close(); &#125;&#125; TCP：Code实现的由键盘输入实现和数据发送-数据写入到文本文档. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*client code*/package TCP_TXT;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class ClientFiles &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub Socket clientSocket = new Socket(&quot;192.168.119.9&quot;, 15360); BufferedReader clientReader = new BufferedReader(new InputStreamReader( System.in)); BufferedWriter clientWriter = new BufferedWriter( new OutputStreamWriter(clientSocket.getOutputStream())); String clientString = null; while ((clientString = clientReader.readLine()) != null) &#123; clientWriter.write(clientString); clientWriter.newLine(); clientWriter.flush(); &#125; clientSocket.close(); &#125;&#125;/*server code*/package TCP_TXT;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerFiles &#123; public static void main(String[] args) throws IOException &#123; File files = new File(&quot;test.txt&quot;); BufferedWriter fileWriter = new BufferedWriter(new FileWriter(files)); ServerSocket serverSocket = new ServerSocket(15360); Socket nextSocket = serverSocket.accept(); BufferedReader serverReader = new BufferedReader(new InputStreamReader( nextSocket.getInputStream())); String serverString = null; while ((serverString = serverReader.readLine()) != null) &#123; if (serverString.equals(&quot;over!&quot;)) &#123; fileWriter.close(); break; &#125; fileWriter.write(serverString); fileWriter.newLine(); fileWriter.flush(); &#125; serverSocket.close(); &#125;&#125; TCP：Code，服务器端接受由客户端文本文件发送的数据- 显示在控制台&amp;写入到文本文件两种方式，尤其提示，服务器端一定要注意关闭流/flush二者必选其一，不然无法显示，但是逻辑没有警告也不报错，但是就是达不到显示or复制文件的效果。 Code如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*for example----客户端*/package TCP_TXT_TO_SERVER;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.Socket;public class ClientPort &#123; public static void main(String[] args) throws IOException &#123; /*socket对象*/ Socket clientSocket = new Socket(&quot;192.168.119.9&quot;, 15360); /*文本文件流*/ BufferedReader clientfiles = new BufferedReader(new FileReader( &quot;F:\\Java\\TestCc\\SourceTxt.txt&quot;)); /*通道数据流 */ BufferedWriter clientWriter = new BufferedWriter( new OutputStreamWriter(clientSocket.getOutputStream())); /*行内容的读取并且写入发送*/ String clientString = null; while ((clientString = clientfiles.readLine()) != null) &#123; clientWriter.write(clientString); clientWriter.newLine(); clientWriter.flush(); &#125; /*通道流，文件流，套接字的关闭.*/ clientfiles.close(); clientWriter.close(); clientSocket.close(); &#125;&#125;/*for example----服务器端*/package TCP_TXT_TO_SERVER;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerPort &#123; public static void main(String[] args) throws IOException &#123; /*服务套接字对象*/ ServerSocket serverSocket = new ServerSocket(15360); /*解析获取套接字，准备解析。*/ Socket nextSocket = serverSocket.accept(); /*将套接字的通道流暴露出来，准备读取通道流，属于流的读取，相对于内存是写入。*/ BufferedReader serverReader = new BufferedReader(new InputStreamReader( nextSocket.getInputStream())); /*文本流的创建， 准备写入到文本写出内存。*/ BufferedWriter filesWriter = new BufferedWriter(new FileWriter( &quot;ServerText.txt&quot;)); String serverString = null; /* this Console expression. */ while ((serverString = serverReader.readLine()) != null) &#123; System.out.println(serverString); &#125; /* this store to text files. */ /*while ((serverString = serverReader.readLine()) != null) &#123; filesWriter.write(serverString); filesWriter.newLine(); filesWriter.flush(); &#125;*/ filesWriter.close(); serverReader.close(); nextSocket.close(); serverSocket.close(); &#125;&#125; 带提示的TCP文本传输，完成后提示客户端且关闭连接-实现上个人认为比较完美。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/*for example-服务器端*/package TCP_TXT_TO_SERVER;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class ServerPort &#123; public static void main(String[] args) throws IOException &#123; /* 服务套接字对象 */ ServerSocket serverSocket = new ServerSocket(15360); /* 解析获取套接字，准备解析。 */ Socket nextSocket = serverSocket.accept(); /* 将套接字的通道流暴露出来，准备读取通道流，属于流的读取，相对于内存是写入。 */ BufferedReader serverReader = new BufferedReader(new InputStreamReader( nextSocket.getInputStream())); /* 文本流的创建， 准备写入到文本写出内存。 */ BufferedWriter filesWriter = new BufferedWriter(new FileWriter( &quot;ServerText.txt&quot;)); String serverString = null; while ((serverString = serverReader.readLine()) != null) &#123; filesWriter.write(serverString); filesWriter.newLine(); filesWriter.flush(); &#125; /* 给客户端发送提示：传输完成！ */ BufferedWriter tipServer = new BufferedWriter(new OutputStreamWriter( nextSocket.getOutputStream())); tipServer.write(&quot;传输完成！&quot;); tipServer.newLine(); /*此行可略。*/ tipServer.flush(); /*无此行，客户端收到提示为null.*/ /nextSocket.shutdownOutput(); /*可略，因为后面有关闭.*/ /* 释放对应资源。 */ filesWriter.close(); serverReader.close(); nextSocket.close(); serverSocket.close(); &#125;&#125;/*for example-客户端*/package TCP_TXT_TO_SERVER;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class ClientPort &#123; public static void main(String[] args) throws IOException &#123; /* socket对象 */ Socket clientSocket = new Socket(&quot;192.168.119.9&quot;, 15360); /* 文本文件流 */ BufferedReader clientfiles = new BufferedReader(new FileReader( &quot;F:\\Java\\TestCc\\SourceTxt.txt&quot;)); /* 通道数据流 */ BufferedWriter clientWriter = new BufferedWriter( new OutputStreamWriter(clientSocket.getOutputStream())); /* 行内容的读取并且写入发送 */ String clientString = null; while ((clientString = clientfiles.readLine()) != null) &#123; clientWriter.write(clientString); clientWriter.newLine();/*此两行不影响显示效果.*/ clientWriter.flush(); &#125; /* 通道流，文件流，套接字的关闭. */ clientSocket.shutdownOutput(); /* 接收服务器端的提示：传输完成！ */ BufferedReader tipFromServer = new BufferedReader( new InputStreamReader(clientSocket.getInputStream())); String temp = tipFromServer.readLine(); System.out.println(&quot;提示：&quot; + temp); clientfiles.close(); clientSocket.close(); &#125;&#125; TCP-服务器端同时接收多个客户端的上传. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*for example*/ - 要实现线程的多线程访问，需要做到的是，将服务器端主实现部分分割，客户端保留。同时主函数调用服务器线程，一旦客户端运行就可以捕捉到数据包，然后将文件存档，利用CurrentMillionTime可以实现名称问题，但是仍然存在一个同时访问情况下的高并发问题。/*客戶端*/import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class UploadClient &#123; public static void main(String[] args) throws IOException &#123; Socket s = new Socket(&quot;192.168.119.9&quot;, 15360); BufferedReader br = new BufferedReader(new FileReader( &quot;TestAa.java&quot;)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( s.getOutputStream())); String line = null; while ((line = br.readLine()) != null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; s.shutdownOutput(); BufferedReader brClient = new BufferedReader(new InputStreamReader( s.getInputStream())); String client = brClient.readLine(); System.out.println(client); br.close(); s.close(); &#125;&#125;/*服务器线程*/import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class UserThread implements Runnable &#123; private Socket s; public UserThread(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; try &#123; BufferedReader br = new BufferedReader(new InputStreamReader( s.getInputStream())); /*文件名問題*/ String newName = System.currentTimeMillis() + &quot;.java&quot;; BufferedWriter bw = new BufferedWriter(new FileWriter(newName)); String line = null; while ((line = br.readLine()) != null) &#123; // 阻塞 bw.write(line); bw.newLine(); bw.flush(); &#125; /*提示*/ BufferedWriter bwServer = new BufferedWriter( new OutputStreamWriter(s.getOutputStream())); bwServer.write(&quot;Over!&quot;); bwServer.flush(); bw.close(); s.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/*服务器主函数*/import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;public class UploadServer &#123; public static void main(String[] args) throws IOException &#123; /*创建ServerSocket对象但是关闭ss.*/ ServerSocket ss = new ServerSocket(11111); while (true) &#123; Socket s = ss.accept(); new Thread(new UserThread(s)).start(); &#125; &#125;&#125; 总结：数据的传输需要 发送端-套接字，写入到内存-BufferedReader-Socket.getInputStreamReader匹配-&gt;写入到流，BufferedWriter-&gt;socket.getOutputStreamWriter…然后自动发送。 服务器端则需要定义ServerSocket，accep函数获取Socket，然后将通道流暴露出来，然后利用BufferReader将流读取到内存，对应BufferedReader.readLine()，获取为String，然后可以直接显示在控制台，or创建BufferWriter-&gt;new BufferedWriter(new FileWriter(“path”))-&gt;利用BufferedWriter对象，调用writer()函数，注意要显示效果，需要传输关闭流/flush即可。]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>网络编程 套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程&定时器&调用运行环境]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F12%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%26%E5%AE%9A%E6%97%B6%E5%99%A8%26%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[多线程进程 进程：(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在进程是程序的基本执行实体,在当代面向线程设计的计算机结构中，进程是线程的容器,程是程序的实体。 多线程：是指从软件或者硬件上实现多个线程并发执行的技术，是为了提高CPU等资源的使用率而采用的一种新技术。将一个执行活动-进程，拆分为多个小的执行片段，片段之间是共享数据而完成进程任务，进而提升整体处理性能。 Java程序运行 Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。 JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。 进程的实现方式： 继承Thread类. 12345678910111213141516171819202122232425262728293031323334353637/*for example*/public final String getName() //获取线程的名称。public final void setName(String //name):设置线程的名称System.out.println(Thread.currentThread().getName()); //控制台显示当前指定对象名字。public class MyThread extends Thread &#123; public MyThread() &#123; &#125; public MyThread(String name)&#123; super(name); &#125; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(getName() + &quot;:&quot; + x); &#125; &#125;&#125;public static void main(String[] args) &#123; /*method:the first...*/ MyThread myThread1 = new MyThread(); MyThread myThread2 = new MyThread(); myThread1.setName(&quot;Tom&quot;); myThread2.setName(&quot;Jack&quot;); myThread1.start(); myThread2.start(); /*method:the second...*/ MyThread Thread1 = new MyThread(&quot;Tom&quot;); MyThread Thread2 = new MyThread(&quot;Jack&quot;); Thread1.start(); Thread2.start(); 实现Runnable接口. 1234567891011121314151617181920212223242526272829public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int x = 0; x &lt; 10; x++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); &#125; &#125;&#125;public class MyRunnable &#123; public static void main(String[] args) &#123; MyRunnable my = new MyRunnable(); /*method:the first...*/ Thread Thread1 = new Thread(my); Thread Thread2 = new Thread(my); Thread1.setName(&quot;Tom&quot;); Thread2.setName(&quot;Jack&quot;); /*method:the second...*/ Thread Thread1 = new Thread(my, &quot;Tom&quot;); Thread Thread2 = new Thread(my, &quot;Jack&quot;); Thread1.start(); Thread2.start(); &#125;&#125; Callable&amp;ExecutorService. 1234567891011121314151617181920212223242526272829/*for example*/ import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors; import java.util.concurrent.Callable;/*Callable:是带泛型的接口，这里指定的泛型其实是call()方法的返回值类型*/@SuppressWarnings(&quot;rawtypes&quot;)class MyCallable implements Callable &#123; /*Callable JDK1.5*/ @Override public Object call() throws Exception &#123; for (int x = 0; x &lt; 50; x++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); &#125; return null; &#125;&#125;public class CallableDemo &#123; public static void main(String[] args) &#123; /*创建线程池对象*/ ExecutorService pool = Executors.newFixedThreadPool(2); pool.submit(new MyCallable()); pool.submit(new MyCallable()); pool.shutdown(); &#125;&#125; 线程的调度和优先级问题 线程的调度：分时调度，时间片轮转机制，而Java是采用抢占式调度。 获取&amp;设置线程优先级：Java中线程运行的优先级自高到底：10级-&gt;1级，默认5级；需要说明的是不是运行的级别越高就保证一定先执行该线程完该线程再执行其他低优先级的线程，只是保证其具有很大的可能有优先级。 线程的控制 休眠线程 1234567891011121314151617181920212223242526272829303132333435363738394041/*for example*//* public static void sleep(long millis) */import java.util.Date;public class ThreadSleep extends Thread &#123; @Override public void run() &#123; for (int x = 0; x &lt; 20; x++) &#123; System.out.println(getName() + &quot;:&quot; + x + &quot;,Date：&quot; + new Date()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 解决直接重命名线程名称.*/ /*public ThreadSleep(String name)&#123; super(name); &#125;*/&#125;public class ThreadSleepDemo &#123; public static void main(String[] args) &#123; ThreadSleep Aa = new ThreadSleep(); ThreadSleep Bb = new ThreadSleep(); ThreadSleep Cc = new ThreadSleep(); /*ThreadSleep Dd = new ThreadSleep(&quot;Smith&quot;);*/ Aa.setName(&quot;Tom&quot;); Bb.setName(&quot;John&quot;); Cc.setName(&quot;Jack&quot;); Aa.start(); Bb.start(); Cc.start(); &#125;&#125; 加入线程 1234567891011121314151617181920212223242526272829303132333435363738394041/*实现join功能*/package CompareTools;class sleepThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;:&quot; + i); &#125; &#125; public sleepThread() &#123; &#125; public sleepThread(String name) &#123; super(name); &#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub sleepThread spOne = new sleepThread(&quot;Tom&quot;); sleepThread spTwo = new sleepThread(&quot;Jack&quot;); sleepThread spThree = new sleepThread(&quot;Smith&quot;); spThree.start(); try &#123; spThree.join(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; spOne.start(); spTwo.start(); &#125;&#125;/*Smith执行完成才继续执行后面的，但若将spThree放到try后面不会有描述的效果。*/ 礼让线程 12345678910111213141516171819202122232425262728293031package CompareTools;class PriorityThread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; /* 实现Runnable无法使用Thread的getName函数. */ System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); Thread.yield(); /*礼让不代表一定是程序严格运行一次就对方执行.*/ &#125; &#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; PriorityThread pt = new PriorityThread(); PriorityThread ptt = new PriorityThread(); Thread trr = new Thread(pt, &quot;Jack&quot;); /*Thread trr = new Thread(pt, &quot;Tom&quot;)一样运行看不出什么问题.*/ Thread tr = new Thread(ptt, &quot;Tom&quot;); tr.setName(&quot;newName&quot;); trr.setName(&quot;newNameName&quot;); tr.start(); trr.start(); &#125;&#125; 守护线程 12345678910111213141516171819202122232425262728293031/*public final void setDaemon(boolean on):将该线程标记为守护线程或用户线程。*/ 当正在运行的线程都是守护线程时，Java 虚拟机退出。/*for example*/td1.setDaemon(true);td2.setDaemon(true);td1.start();td2.start();System.out.println(&quot;Over!&quot;);result:--循环结构写稍微大一些可以看到效果，循环到部分虚拟机就退出。Over!Thread-1:0Thread-0:0Thread-1:1Thread-0:1Thread-1:2Thread-0:2Thread-1:3Thread-1:4Thread-1:5Thread-1:6Thread-0:3Thread-1:7Thread-1:8Thread-0:4Thread-1:9Thread-1:10... 优先级设置 1234567891011121314151617181920212223242526272829303132package CompareTools;/*设置优先级不能保证一定是是优先级高的限制性，java中只能表示优先，但是不是先执行完高级别的再执行低级别.*/class PriorityThread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; ++i) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; PriorityThread pt = new PriorityThread(); Thread tr = new Thread(pt, &quot;Jack&quot;); Thread trr = new Thread(pt, &quot;Tom&quot;); Thread trrr = new Thread(pt, &quot;Smith&quot;); tr.setPriority(10); trrr.setPriority(1); tr.start(); trr.start(); trrr.start(); &#125;&#125; 终止线程 12345678910111213141516171819202122232425262728293031import java.util.Date;public class ThreadStop extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;开始执行：&quot; + new Date()); /*睡眠10s*/ try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;线程被终止了！&quot;); &#125; System.out.println(&quot;结束执行：&quot; + new Date()); &#125;&#125;public class ThreadStopDemo &#123; public static void main(String[] args) &#123; ThreadStop ts = new ThreadStop(); ts.start(); /*3s不继续执行，中断.*/ try &#123; Thread.sleep(3000); /*ts.stop(); 直接终止.*/ ts.interrupt(); //线程被终止，结束执行还是可以显示. &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 加入并查看线程组 123456789101112131415161718192021222324252627282930313233343536373839public class ThreadGroupDemo &#123; public static void main(String[] args)&#123; methodOne(); methodTwo(); &#125; private static void methodTwo() &#123; ThreadGroup SetGroup = new ThreadGroup(&quot;NewGroupName&quot;); MyRunnable SetThreadRunable = new MyRunnable(); Thread t1 = new Thread(SetGroup, SetThreadRunable, &quot;TheOne&quot;); Thread t2 = new Thread(SetGroup, SetThreadRunable, &quot;TheTwo&quot;); System.out.println(t1.getThreadGroup().getName()); System.out.println(t2.getThreadGroup().getName()); SetGroup.setDaemon(true); &#125; private static void methodOne() &#123; MyRunnable SourceRunable = new MyRunnable(); Thread t1 = new Thread(SourceRunable, &quot;FirstThread&quot;); Thread t2 = new Thread(SourceRunable, &quot;SecondThread&quot;); /*查看默认情况下，线程所属组别--默认是Main.*/ ThreadGroup defaultTg1 = t1.getThreadGroup(); ThreadGroup defaultTg2 = t2.getThreadGroup(); String nameOne = defaultTg1.getName(); String nameTwo = defaultTg2.getName(); System.out.println(nameOne); System.out.println(nameTwo); System.out.println(Thread.currentThread().getThreadGroup().getName()); &#125;&#125; 线程的生命周期 新建-&gt;就绪-&gt;运行-&gt;阻塞-&gt;死亡。 车站买票完整实现 描述：买票用多线程实现，可以考虑适当的延迟，或者是为了保证程序的健壮性，保证问题不被掩盖掉。问题有这两种：一个是同一张车票卖了两次，二是车票卖到了负数。 如图出错： 为了数据的安全性需要添加锁进行实现而锁有两种：一种是Synchronized实现，一种是JDK1.4之后的lock实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*for example*//*method：the first... */class SellTicket implements Runnable &#123; private static int tickets = 100; private Object obj = new Object(); @Override public void run() &#123; while (true) &#123; /*在需要锁的地方添加锁对象，或者用obj替换SellTicket.class亦可！*/ /*this=SellTicket.class*/ synchronized (SellTicket.class) &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(150); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;printing&quot; + (tickets--) + &quot;th ticke！&quot;);&#125;&#125;&#125;&#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象. SellTicket st = new SellTicket(); Thread thead1 = new Thread(st, &quot;Windows-1：&quot;); Thread thead2 = new Thread(st, &quot;Windows-2：&quot;); Thread thead3 = new Thread(st, &quot;Windows-3：&quot;); thead1.start(); thead2.start(); thead3.start(); &#125;&#125;/*method：the second... */package CompareTools;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class SellTicket implements Runnable &#123; private static int tickets = 100; private Lock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; lock.lock(); if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;Printing&quot; + (tickets--) + &quot;th tickes!&quot;); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; SellTicket sourceClass = new SellTicket(); Thread sta = new Thread(sourceClass, &quot;Windows-1:&quot;); Thread stb = new Thread(sourceClass, &quot;Windows-2:&quot;); Thread stc = new Thread(sourceClass, &quot;Windows-3:&quot;); sta.start(); stb.start(); stc.start(); &#125; &#125; 关于使用继承Thread&amp;lock 未曾达到预期结果，出错代码在runable下运行正常，原因可能是实现接口的子类存在于Thread子类特有的差别，目前还无法明白具体原因，出错实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*for example--出错.*/--lock锁搭配try...finally...出错。package CompareTools;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class SellTicket extends Thread &#123; private static int tickets = 100; private Lock lock = new ReentrantLock(); public SellTicket() &#123; &#125; public SellTicket(String name) &#123; super(name); &#125; @Override public void run() &#123; while (true) &#123; try&#123; lock.lock(); if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;Printing&quot; + (tickets--) + &quot;th tickes!&quot;); &#125; &#125;finally&#123; lock.unlock();&#125; &#125; &#125; &#125;public class TestFiles &#123; public static void main(String[] args) &#123; SellTicket sta = new SellTicket(&quot;Windows-1:&quot;); SellTicket stb = new SellTicket(&quot;Windows-2:&quot;); SellTicket stc = new SellTicket(&quot;Windows-3:&quot;); sta.start(); stb.start(); stc.start(); &#125;&#125; 多线程安全判定 是否有多线程环境 是否有共享数据 是否有多条语句操作共享数据 同步方法 将方法有Synchronized修饰，可以同步方法。 Code eg: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class SellTicket implements Runnable &#123; private static int tickets = 100; private int x = 0; @Override public void run() &#123; while (true) &#123; if (x % 2 == 0) &#123; synchronized (SellTicket.class) &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;printing&quot; + (tickets--) + &quot;th ticket! &quot;); &#125; &#125; &#125; else &#123; sellTicket(); &#125; x++; &#125; &#125; private static synchronized void sellTicket() &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;printing&quot; + (tickets--) + &quot;th ticket! &quot;); &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; SellTicket sourceClass = new SellTicket(); Thread window_1 = new Thread(sourceClass, &quot;window_1:\t&quot;); Thread window_2 = new Thread(sourceClass, &quot;window_2:\t&quot;); Thread window_3 = new Thread(sourceClass, &quot;window_3:\t&quot;); window_1.start(); window_2.start(); window_3.start(); &#125;&#125; 同步的使用可以修改为对：要求线程严格遵守一个线程执行一次的要求，也可以利用经典的互斥问题，哲学家就餐问题和生产消费问题。 互斥&amp;同步实现 描述：问题的起源。 首先是由于线程的不严格控制导致的生产消费的死锁问题，也就是多个对象占有其他对象所必需的资源，导致自己无法获取资源，陷入无限等待的姿态。 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 解除死锁状态 死锁预防：这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 死锁避免：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。 死锁检测和解除：先检测，这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。 Code 同步互斥: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/*Object类中提供的三个方法： wait():等待 notify():唤醒单个线程 notifyAll():唤醒所有线程 为什么不定义在Thread类中? 这些方法的调用必须通过锁对象Lock调用，而我们使用的锁对象可能是任意锁对象. 所以，这些方法必须定义在Object类中是为了实现对象的通用性。*//* Tom-5. * Jack-6. *//*该部分代码块实现的是：多线程情况下，保证线程运行一步就暂停，而然另外线程运行*/package CompareTools;class Student &#123; String name; int age; boolean flag;&#125;class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; synchronized (s) &#123; /*锁定局部，而实际造成的结果是完全锁定执行，防止干扰*/ if(!s.flag)&#123; /*为true则获取值，显示在界面*/ try &#123; s.wait(); /*解锁+等待...*/ &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s.name + &quot;---&quot; + s.age); s.flag = false; /*使用完成后就修改，保证SetThread运行.*/ s.notify(); /*唤醒GetThread=唤醒...*/&#125;&#125;&#125;&#125;class SetThread implements Runnable &#123; private Student s; private int x = 0; public SetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; synchronized (s) &#123; /*锁定局部，而实际造成的结果是完全锁定执行，防止干扰*/ if(s.flag)&#123; /*为flase执行赋值操作...*/ try &#123; s.wait(); /*解锁+等待...*/ &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x % 2 == 0) &#123; s.name = &quot;Five&quot;; s.age = 5; &#125; else &#123; s.name = &quot;Six&quot;; s.age = 6; &#125; x++; s.flag = true; /*使用完成后就修改，保证GetThread运行.*/ s.notify(); /*唤醒GetThread=唤醒..*/&#125;&#125;&#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; Student s = new Student(); SetThread st = new SetThread(s); GetThread gt = new GetThread(s); Thread t1 = new Thread(st); Thread t2 = new Thread(gt); t1.start(); t2.start(); &#125;&#125; 经典的互斥同步-生产消费问题 描述：假设消费者生产者使用一个容器，生产者将产品生产到容器中，消费者将容器中的产品拿出来消费。 程序进入后需要首先检测信号量，判断是否容器存在产品，若不存在，生产者互斥占有并且生产产品放至容器，然后退出互斥占有状态，关闭锁。保证消费者可以获取容器并且使用，消费者使用使用时设置互斥锁锁定使用，使用完成返回容器，放开互斥锁。并设置信号量，保证自己不占有为空的容器，导致死锁。 Code - 互斥同步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/*for example*/上代码结构： - 设置对象简单具体类，是为了使用共享boolean变量，和设置/获取方法。 - 设置互斥设置名字 &lt;=&gt; 生产者互斥同步生产产品. - 设置互斥获取名字 &lt;=&gt; 消费者互斥同步消费产品. - 主函数，调用两个线程：互斥设置&amp;互斥共享线程。 - 创建两个对象，进行类似生产消费操作code。 package CompareTools;class Student &#123; String name; int age; boolean flag;&#125;class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; synchronized (s) &#123; /* 锁定局部，而实际造成的结果是完全锁定执行，防止干扰 */ if (!s.flag) &#123; /* 为true则获取值，显示在界面 */ try &#123; s.wait(); /* 解锁+等待... */ &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+ s.name + &quot;---&quot; + s.age); s.flag = false; /* 使用完成后就修改，保证SetThread运行. */ s.notify(); /* 唤醒GetThread=唤醒... */ &#125; &#125; &#125;&#125;class SetThread implements Runnable &#123; private Student s; private int x = 0; public SetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; synchronized (s) &#123; /* 锁定局部，而实际造成的结果是完全锁定执行，防止干扰 */ if (s.flag) &#123; /* 为flase执行赋值操作... */ try &#123; s.wait(); /* 解锁+等待... */ &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x % 2 == 0) &#123; s.name = &quot;Five&quot;; s.age = 5; &#125; else &#123; s.name = &quot;Six&quot;; s.age = 6; &#125; System.out.println(Thread.currentThread().getName()); x++; s.flag = true; /* 使用完成后就修改，保证GetThread运行. */ s.notify(); /* 唤醒GetThread=唤醒.. */ &#125; &#125; &#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; Student s = new Student(); SetThread st = new SetThread(s); GetThread gt = new GetThread(s); Thread t1 = new Thread(st, &quot;st&quot;); Thread t2 = new Thread(gt, &quot;gt&quot;); t1.start(); t2.start(); System.out.println(&quot;------this is a dividing line------&quot;); Student ss = new Student(); SetThread stt = new SetThread(ss); GetThread gtt = new GetThread(ss); Thread t11 = new Thread(stt, &quot;stt&quot;); Thread t22 = new Thread(gtt, &quot;gtt&quot;); t11.start(); t22.start(); &#125;&#125; 运行结果： 运行结果一： 运行结果二： 改进的生产者消费者Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/*for example*//*Tips:添加生产消费过程，方面查看逻辑，同时存在第二次运行可能存在3比2先走，只需要清理控制台，等几秒钟再执行即可，因为Java没有指针不能操作内存，而自动回收机制效率不高。*/package CompareTools;class Student &#123; String name = &quot;Products&quot;; /*flag判断的是容器是否存在商品，存在true；不存在false.*/ boolean flag = false;&#125;class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; if (s.flag) &#123; /*有成品則消費.*/ synchronized (s) &#123; /* 锁定局部互斥消费，防止干扰 */ System.out.println(Thread.currentThread().getName()+&quot;expensing &quot;+ s.name); s.flag = false; /* 使用完成后就修改，保证生产者运行. */ s.notify(); /* 唤醒GetThread=唤醒... */ &#125; &#125; &#125; &#125;&#125;class SetThread implements Runnable &#123; private Student s; private int x = 0; public SetThread(Student s) &#123; this.s = s; &#125; @Override public void run() &#123; while (true) &#123; if (!s.flag) &#123; /*没有产品则生产产品。*/ synchronized (s) &#123; /* 锁定局部互斥生产，防止干扰 */ if (x % 2 == 0) &#123; s.name = &quot;CellPhone-2&quot;; &#125; else &#123; s.name = &quot;Pad-3&quot;; &#125; System.out.println(Thread.currentThread().getName()+&quot;Producting: &quot; + s.name );// result：two x++; s.flag = true; /* 使用完成后就修改，保证消费者运行. */ s.notify(); /* 唤醒GetThread=唤醒...*/ &#125; &#125; &#125; &#125;&#125;public class TestFiles &#123; public static void main(String[] args) &#123; Student s = new Student(); SetThread st = new SetThread(s); GetThread gt = new GetThread(s); Thread t1 = new Thread(st, &quot;ThreadOneSet: &quot;); Thread t2 = new Thread(gt, &quot;ThreadOneGet: &quot;); t1.start(); t2.start(); System.out.println(&quot;------this is a dividing line------&quot;); Student ss = new Student(); SetThread stt = new SetThread(ss); GetThread gtt = new GetThread(ss); Thread t11 = new Thread(stt, &quot;ThreadTwoSet: &quot;); Thread t22 = new Thread(gtt, &quot;ThreadTwoGet: &quot;); t11.start(); t22.start(); &#125;&#125; 线程池 线程池，工具类，所有函数均由static修饰。 常用函数Code如下： 123456789101112131415161718192021222324import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;class MyRunnable implements Runnable&#123; public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); &#125;&#125;&#125;public class ExecutorsDemo &#123; public static void main(String[] args) &#123; // 创建一个线程池对象，参数为线程个数。 // public static ExecutorService newFixedThreadPool(int nThreads) ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象的线程. pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); /*结束线程池，否则不会死亡，等待下一对象来说使用.*/ pool.shutdown(); &#125;&#125; Callable&amp;executors Code eg: 12345678910111213141516171819202122232425262728import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors; import java.util.concurrent.Callable;/*Callable:是带泛型的接口，这里指定的泛型其实是call()方法的返回值类型*/@SuppressWarnings(&quot;rawtypes&quot;)class MyCallable implements Callable &#123; /*Callable JDK1.5*/ @Override public Object call() throws Exception &#123; for (int x = 0; x &lt; 50; x++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); &#125; return null; &#125;&#125;public class CallableDemo &#123; public static void main(String[] args) &#123; /*创建线程池对象*/ ExecutorService pool = Executors.newFixedThreadPool(2); pool.submit(new MyCallable()); pool.submit(new MyCallable()); pool.shutdown(); &#125;&#125; Callable&amp;executors-&gt;sum. Code eg:sum. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/* * Sum. */class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125;public class CallableDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService pool = Executors.newFixedThreadPool(2); Future&lt;Integer&gt; result_01 = pool.submit(new MyCallable(50)); Future&lt;Integer&gt; result_02 = pool.submit(new MyCallable(100)); Integer sumOne = result_01.get(); Integer sumTwo = result_02.get(); System.out.println(&quot;Sum&lt;50&gt;: &quot; + sumOne); System.out.println(&quot;Sum&lt;100&gt;: &quot; + sumTwo); /* 结束线程池. */ pool.shutdown(); &#125;&#125; 匿名内部类&amp;线程的使用 匿名内部本质上是需要一个接口的实现类或者是抽象类的子类对象，实现润able的内部类有如下几种实现方法。 Code eg: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*for example*//* * 匿名内部类的格式： * new 类名或者接口名() &#123; * 重写方法; * &#125;; * 本质：是该类或者接口的子类对象。 */public class ThreadInner &#123; public static void main(String[] args) &#123; /*继承Thread类来实现多线程*/ /*new Thread()&#123;override Code block&#125;.start();*/ new Thread() &#123; public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); &#125; &#125; &#125;.start(); /*实现Runnable接口来实现多线程*/ /*new Thread(override Code block)&#123;&#125;.start();*/ new Thread(new Runnable() &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + x); &#125; &#125; &#125;) &#123; &#125;.start(); /*更有难度的嵌套，本质上考验到底执行哪一部分.*/ /*new Thread(new Runable()代码块)&#123;抽象方法Runable代码块&#125;.start();-按照逻辑顺序，走子类对象部分，也就是new Thread()&#123;override Code block&#125;.start();*/ new Thread(new Runnable() &#123; @Override public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(&quot;hello&quot; + &quot;:&quot; + x); &#125; &#125; &#125;) &#123; public void run() &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(&quot;world&quot; + &quot;:&quot; + x); &#125; &#125; &#125;.start(); &#125;&#125; Timer定时器 提供一个类Timer实现定时执行操作的功能。 Code eg：文件夹删除. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.File;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;class DeleteFolder extends TimerTask &#123; @Override public void run() &#123; File srcFolder = new File(&quot;其他文件&quot;); deleteFolder(srcFolder); &#125; /*递归删除目录*/ public void deleteFolder(File srcFolder) &#123; File[] fileArray = srcFolder.listFiles(); if (fileArray != null) &#123; for (File file : fileArray) &#123; if (file.isDirectory()) &#123; deleteFolder(file); &#125; else &#123; System.out.println(file.getName() + &quot;:&quot; + file.delete()); &#125; &#125; System.out.println(srcFolder.getName() + &quot;:&quot; + srcFolder.delete()); &#125; &#125;&#125;public class TimerTest &#123; public static void main(String[] args) throws ParseException &#123; Timer t = new Timer(); String s = &quot;10:05 2018/11/11&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm yyyy/MM/dd&quot;); Date d = sdf.parse(s); t.schedule(new DeleteFolder(), d); &#125;&#125;]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>定时器 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据操作流&内存流&打印流]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F09%2F%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%B5%81%26%E5%86%85%E5%AD%98%E6%B5%81%26%E6%89%93%E5%8D%B0%E6%B5%81%2F</url>
    <content type="text"><![CDATA[操作流流文件实现的登录注册校验 DAO-接口操作集 POJO-简单用户定义集 DAO.impl-接口操作实现 Code总体逻辑： 定义操作接口：注册-登录。 定义具体实现接口：注册-登录。 操作类接口保证文件的存在性，必须将创建文件作为静态代码块实现。 注册将user对象的Name=PassWord通过打开user.txt文件对象流写入到user.txt，考虑写入可能失败所以需要使用try…catch…finally去实现，返回boolean型。 登录类，通过打开文件对象流，读取每一行数据，并且通过split函数获取账号=密码，与通过界面输入的值通过equals匹配，若成功，返回true。 对象类：定义简单的用户对象，以及对应的成员变量和成员方法。 主函数类：界面控制问题：获取选项；判断合理性；调用对应的函数即可。 eg: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220/*for example*/import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Scanner;/*用户定义*/class User &#123; private String username; private String password; public User() &#123; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125;/*操作接口定义*/interface UserDao &#123; public abstract boolean isLogin(String username, String password); public abstract void regist(User user);&#125;/*接口具体实现*/class UserDaoImpl implements UserDao &#123; //保证存储文件的存在. private static File file = new File(&quot;user.txt&quot;); static &#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; System.out.println(&quot;创建文件失败.&quot;); // e.printStackTrace(); &#125; &#125; @Override public boolean isLogin(String username, String password) &#123; boolean flag = false; BufferedReader br = null; try &#123; br = new BufferedReader(new FileReader(file)); String line = null; while ((line = br.readLine()) != null) &#123; String[] datas = line.split(&quot;=&quot;); if (datas[0].equals(username) &amp;&amp; datas[1].equals(password)) &#123; flag = true; break; &#125; &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;用户登录找不到信息所在的文件.&quot;); // e.printStackTrace(); &#125; catch (IOException e) &#123; System.out.println(&quot;用户登录失败.&quot;); // e.printStackTrace(); &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;用户登录释放资源失败.&quot;); // e.printStackTrace(); &#125; &#125; &#125; return flag; &#125; @Override public void regist(User user) &#123; /* * 数据的存储规则为:用户名=密码. */ BufferedWriter bw = null; try &#123; bw = new BufferedWriter(new FileWriter(file, true)); bw.write(user.getUsername() + &quot;=&quot; + user.getPassword()); bw.newLine(); bw.flush(); &#125; catch (IOException e) &#123; System.out.println(&quot;用户注册失败.&quot;); // e.printStackTrace(); &#125; finally &#123; if (bw != null) &#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; System.out.println(&quot;用户注册释放资源失败.&quot;); // e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;/*Game主函数*/class GuessNumber &#123; private GuessNumber() &#123; &#125; public static void start() &#123; int number = (int) (Math.random() * 100) + 1; int count = 0; while (true) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入数据(1-100)：&quot;); int guessNumber = sc.nextInt(); count++; // 判断 if (guessNumber &gt; number) &#123; System.out.println(&quot;你猜的数据&quot; + guessNumber + &quot;大了.&quot;); &#125; else if (guessNumber &lt; number) &#123; System.out.println(&quot;你猜的数据&quot; + guessNumber + &quot;小了.&quot;); &#125; else &#123; System.out.println(&quot;恭喜你，&quot; + count + &quot;次就猜中了!&quot;); break; &#125; &#125; &#125;&#125;/*主函数部分*/public class InterCalc &#123; public static void main(String[] args) &#123; // 为了能够回来 while (true) &#123; // 欢迎界面，给出选择项 System.out.println(&quot;--------------欢迎光临--------------&quot;); System.out.println(&quot;1 登录&quot;); System.out.println(&quot;2 注册&quot;); System.out.println(&quot;3 退出&quot;); System.out.println(&quot;请输入你的选择:&quot;); Scanner sc = new Scanner(System.in); String choiceString = sc.nextLine(); // 多态，接口内部调用User。 UserDao ud = new UserDaoImpl(); switch (choiceString) &#123; case &quot;1&quot;: // 登录界面，请输入用户名和密码 System.out.println(&quot;--------------登录界面--------------&quot;); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); boolean flag = ud.isLogin(username, password); if (flag) &#123; System.out.println(&quot;登录成功。&quot;); System.out.println(&quot;你玩吗?y/n&quot;); while (true) &#123; String resultString = sc.nextLine(); if (resultString.equalsIgnoreCase(&quot;y&quot;)) &#123; // 玩游戏 GuessNumber.start(); System.out.println(&quot;你还玩吗?y/n&quot;); &#125; else &#123; break; &#125; &#125; System.out.println(&quot;谢谢使用，欢迎下次再来!&quot;); System.exit(0); // break; //这里写break，结束的是switch &#125; else &#123; System.out.println(&quot;用户名或者密码有误,登录失败!&quot;); &#125; break; case &quot;2&quot;: // 欢迎界面，请输入用户名和密码 System.out.println(&quot;--------------注册界面--------------&quot;); System.out.println(&quot;请输入用户名：&quot;); String newUsername = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String newPassword = sc.nextLine(); User user = new User(); user.setUsername(newUsername); user.setPassword(newPassword); ud.regist(user); System.out.println(&quot;注册成功.&quot;); break; case &quot;3&quot;: System.out.println(&quot;欢迎下次再来！&quot;); System.exit(0); break; default: System.out.println(&quot;请重新选择正确的选项！&quot;); break; &#125; &#125; &#125;&#125; 带本地文件验证次数的登录注册验证—转到文章最后。 数据操作流 - 操作基本类型数据的流 DataOutputStream(OutputStream out) 创建一个新的数据输出流，以将数据写入指定的底层输出流。 DataInputStream DataOutputStream codeDemo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 数据输入流：DataInputStream * DataInputStream(InputStream in). * 数据输出流：DataOutputStream * DataOutputStream(OutputStream out). */public class DataStream&#123; public static void main(String[] args) throws IOException &#123; write(); read(); &#125;private static void read() throws IOException &#123; // DataInputStream(InputStream in) DataInputStream dis = new DataInputStream( new FileInputStream(&quot;dos.txt&quot;)); // 读数据 byte b = dis.readByte(); short s = dis.readShort(); int i = dis.readInt(); long l = dis.readLong(); float f = dis.readFloat(); double d = dis.readDouble(); char c = dis.readChar(); boolean bb = dis.readBoolean(); dis.close(); System.out.println(b); System.out.println(s); System.out.println(i); System.out.println(l); System.out.println(f); System.out.println(d); System.out.println(c); System.out.println(bb);&#125;private static void write() throws IOException &#123; // DataOutputStream(OutputStream out) // 创建数据输出流对象 DataOutputStream dos = new DataOutputStream(new FileOutputStream( &quot;dos.txt&quot;)); // 写数据 dos.writeByte(10); dos.writeShort(100); dos.writeInt(1000); dos.writeLong(10000); dos.writeFloat(12.34F); dos.writeDouble(12.56); dos.writeChar(&apos;a&apos;); dos.writeBoolean(true); dos.close();&#125;&#125; 内存操作流描述：有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。 ByteArrayInputStream,ByteArrayOutputStream. CharArrayReader,CharArrayWriter. StringReader,StringWriter. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*for example*/import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;/* * 内存操作流：用于处理临时存储信息的，程序结束，数据就从内存中消失,且数据的操作不需要关闭流对象。 * 字节数组： * ByteArrayInputStream * ByteArrayOutputStream * 字符数组： * CharArrayReader * CharArrayWriter * 字符串： * StringReader * StringWriter */public class ByteArrayStream&#123; public static void main(String[] args) throws IOException &#123; // 写数据 // ByteArrayOutputStream() ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 写数据 for (int x = 0; x &lt; 10; x++) &#123; baos.write((&quot;hello&quot; + x).getBytes()); &#125; // 释放资源 // 通过查看源码我们知道这里什么都没做，所以根本不需要close(). // baos.close(); // public byte[] toByteArray() byte[] bys = baos.toByteArray(); // 读数据 // ByteArrayInputStream(byte[] buf) ByteArrayInputStream bais = new ByteArrayInputStream(bys); int by = 0; while ((by = bais.read()) != -1) &#123; System.out.print((char) by); &#125; // bais.close(); &#125;&#125; 打印流 描述：包括字节打印流，字符打印流。 特点： 只操作目的地,不操作数据源,也就是说只有写函数没有读取函数。 可以操作任意类型的数据。 如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新。 可以直接操作文件. 直接操作文件 1234567891011121314/*for example*//*复制文本文件*/BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));/*启动自动刷新：包括写入，写入新行，刷新等操作。*/PrintWriter pw = new PrintWriter(new FileWriter(&quot;b.txt&quot;),true);String line = null;while((line=br.readLine())!=null) &#123; pw.println(line);&#125;pw.close();br.close(); 标准输入输出流 System类中的两个成员变量： 12public static final InputStream in “标准”输入流。public static final PrintStream out “标准”输出流。 三种键盘录入方式 main方法的args接收参数，很少使用。表现方式为：public static void Main(String[] args){}. System.in通过BufferedReader进行包装 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); Scanner Scanner sc = new Scanner(System.in); 输出语句的原理和如何使用字符流输出数据. 123456789101112131415161718System.out.println(&quot;helloworld&quot;); //reg. PrintStream ps = System.out; //reg1.ps.println(&quot;helloworld&quot;); //reg2./*System.out用字符缓冲流包装使用.*/BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));bw.write(&quot;hello&quot;);bw.newLine();bw.write(&quot;world&quot;);bw.newLine();bw.write(&quot;java&quot;);bw.newLine();bw.flush();bw.close(); 随机访问流 RandomAccessFile类不属于流，是Object类的子类。 它融合了InputStream和OutputStream的功能。 支持对文件的随机访问读取和写入。 1234public RandomAccessFile(String name,String mode)： 第一个参数是文件路径，第二个参数是操作文件的模式。 模式有四种，我们最常用的一种叫&quot;rw&quot;,这种方式表示我既可以写数据，也可以读取数据。 mode：must be one of &quot;r&quot;, &quot;rw&quot;, &quot;rws&quot;, or &quot;rwd&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*for example*/import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileDemo &#123; public static void main(String[] args) throws IOException &#123; write(); read(); &#125; private static void read() throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(&quot;raf.txt&quot;, &quot;r&quot;); int i = raf.readInt(); System.out.print(i); System.out.println(&quot;\t当前指针位置：&quot; + raf.getFilePointer()); char ch = raf.readChar(); System.out.print(ch); System.out.println(&quot;\t当前指针位置：&quot; + raf.getFilePointer()); String s = raf.readUTF(); System.out.print(s); System.out.println(&quot;\t当前指针位置：&quot; + raf.getFilePointer()); String ss = raf.readUTF(); System.out.print(ss); System.out.println(&quot;\t当前指针位置：&quot; + raf.getFilePointer()); String sss = raf.readUTF(); System.out.print(sss); System.out.println(&quot;\t当前指针位置：&quot; + raf.getFilePointer()); System.out.println(&quot;------this is a dividing line------&quot;); raf.seek(4); ch = raf.readChar(); System.out.println(ch); &#125; private static void write() throws IOException &#123; RandomAccessFile raf = new RandomAccessFile(&quot;raf.txt&quot;, &quot;rw&quot;); raf.writeInt(100); raf.writeChar(&apos;a&apos;); raf.writeUTF(&quot;中华&quot;); raf.writeUTF(&quot;人民&quot;); raf.writeUTF(&quot;共和国&quot;); raf.close(); &#125;&#125;result:100 当前指针位置：4a 当前指针位置：6中华 当前指针位置：14人民 当前指针位置：22共和国 当前指针位置：33------this is a dividing line------a/* 为什么a指针4,中华为14，因为多读两个，后面的几个string就是验证这个表现的.*/ 合并流 简单的描述就是将把多个输入流的数据写到一个输出流中，可以作为文件的复制合并操作。 构造方法： 12SequenceInputStream(InputStream s1, InputStream s2) .SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e). 文件合并 1/*for example:两种方式实现的文件合并.*/ 12345678910111213141516171819202122232425262728293031/* 要求：a.txt+b.txt=c.txt*/import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.SequenceInputStream;public class SequenceInputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; /*SequenceInputStream(InputStream s1, InputStream s2)*/ InputStream s1 = new FileInputStream(&quot;a.txt&quot;); InputStream s2 = new FileInputStream(&quot;b.txt&quot;); SequenceInputStream sis = new SequenceInputStream(s1, s2); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(&quot;c.txt&quot;)); byte[] bys = new byte[1024]; int len = 0; while ((len = sis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); sis.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/* 要求：a.txt+b.txt+c.txt=final.txt,如下：*/import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.SequenceInputStream;import java.util.Enumeration;import java.util.Vector;public class SequenceInputStreamDemo2 &#123; public static void main(String[] args) throws IOException &#123; // ByteArrayStreamDemo.java,CopyFileDemo.java,DataStreamDemo.java // SequenceInputStream(Enumeration e) // Enumeration&lt;E&gt; elements() Vector&lt;InputStream&gt; v = new Vector&lt;InputStream&gt;(); InputStream s1 = new FileInputStream(&quot;a.txt&quot;); InputStream s2 = new FileInputStream(&quot;b.txt&quot;); InputStream s3 = new FileInputStream(&quot;c.txt&quot;); v.add(s1); v.add(s2); v.add(s3); Enumeration&lt;InputStream&gt; en = v.elements(); SequenceInputStream sis = new SequenceInputStream(en); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(&quot;final.txt&quot;)); byte[] bys = new byte[1024]; int len = 0; while ((len = sis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); sis.close(); &#125;&#125; 序列化流描述:可以把对象写入文本文件或者在网络中传输。 序列化&amp;反序列化 序列化流：把对象按照流一样的方式存入文本文件或者在网络中传输。对象 – 流数据(ObjectOutputStream)。 反序列化流:把文本文件中的流对象数据或者网络中的流对象数据还原成对象。流数据 – 对象ObjectInputStream)。使用方法： 123456让要被序列化的对象所属类实现序列化接口-&gt; 接口为：Serializable-&gt;由于一般是读取之前存储的数据对象，而不是存储&amp;读取，所以一旦对原对象进行修改后，将报错：serialVersionUID的匹配性问题-&gt; 解决办法：使用第一个选项使用默认or第二个使用动态serialVersionUID-&gt; 可能对某些对象的成员变量不需要写入，可以使用transient来修饰。 Serializable-----该接口是一个标记接口。没有功能需要实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*for example*//*POJO--简单对象类*/import java.io.Serializable;public class Person implements Serializable &#123; //序列化接口，无内容的标记接口，目的是对IO格式的匹配。 private String name; private transient int age; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125;/*主函数类*/import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class ObjectStream&#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; write(); read(); &#125; /*反序列化：流-&gt;还原对象.*/ private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream( &quot;oos.txt&quot;)); Object obj = ois.readObject(); ois.close(); System.out.println(obj); &#125; /*序列化：对象-流.*/ private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream( &quot;oos.txt&quot;)); Person p = new Person(&quot;Tom&quot;, 3 ); oos.writeObject(p); oos.close(); &#125;&#125; Properties描述：Properties类表示一组持久的属性。 Properties可以保存到流中或从流中加载。 属性列表中的每个键及其对应的值都是一个字符串。属性列表可以包含另一个属性列表作为其“默认值”; 如果在原始属性列表中找不到属性键，则会搜索此第二个属性列表。 因为Properties从继承Hashtable时， put种putAll方法可应用于Properties对象。 强烈不鼓励使用它们，因为它们允许调用者插入其键或值不是Strings 。 应该使用setProperty方法。 如果store或save方法在包含非String键或值的“受损害” Properties对象上调用，则调用将失败。 类似地，如果在包含非String密钥的“受损害” Properties对象上调用propertyNames或list方法的调用将失败。 简而言之：就是一组持久的属性Hashtable子类，键值对都是String的数集。 继承结构如下： 特有or常用函数 1234567891011121314151617181920212223242526import java.util.Properties;import java.util.Set;/* * Properties:属性集合类,是一个可以和IO流相结合使用的集合类。 * Properties 可保存在流中或从流中加载,属性列表中每个键及其对应值都是一个字符串。 * * 是Hashtable的子类=&gt;是一个Map集合。 */public class PropertiesDemo &#123; public static void main(String[] args) &#123; //错误用法：Properties&lt;String, String&gt; prop = new Properties&lt;String, String&gt;(); Properties prop = new Properties(); prop.put(&quot;001&quot;, &quot;hello&quot;); prop.put(&quot;002&quot;, &quot;world&quot;); prop.put(&quot;003&quot;, &quot;java&quot;); Set&lt;Object&gt; set = prop.keySet(); for (Object key : set) &#123; Object value = prop.get(key); System.out.println(key + &quot;---&quot; + value); &#125; &#125;&#125; 1234567891011121314151617181920212223242526/*public Object setProperty(String key,String value) //添加元素键值对组。public String getProperty(String key) //由键获取值。public Set&lt;String&gt; stringPropertyNames() //获取键集合，属性指定为String。*/import java.util.Properties;import java.util.Set; public class PropertiesCc &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); prop.setProperty(&quot;Jack&quot;, &quot;5&quot;); prop.setProperty(&quot;Tom&quot;, &quot;2&quot;); prop.setProperty(&quot;coffee&quot;, &quot;3&quot;); /*public Set&lt;String&gt; stringPropertyNames():获取所有的键的集合*/ Set&lt;String&gt; set = prop.stringPropertyNames(); for (String key : set) &#123; String value = prop.getProperty(key); System.out.println(key + &quot;---&quot; + value); &#125; &#125;&#125; Properties&amp;IO流 把集合中的数据存储到文本文件中 12public void store(Writer writer,String comments).public void store(OutputStream out,String comments). 把键值对形式的文本文件内容加载到集合中 12public void load(Reader reader).public void load(InputStream inStream). Code-eg: 123456789101112131415161718192021222324252627282930313233343536373839import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.Reader;import java.io.Writer;import java.util.Properties;public class PropertiesCc&#123; public static void main(String[] args) throws IOException &#123; myLoad(); myStore(); &#125; private static void myStore() throws IOException &#123; Properties prop = new Properties(); prop.setProperty(&quot;Jack&quot;, &quot;5&quot;); prop.setProperty(&quot;Tom&quot;, &quot;2&quot;); prop.setProperty(&quot;coffee&quot;, &quot;3&quot;); /*public void store(Writer writer,String comments):把集合中的数据存储到文件。*/ Writer w = new FileWriter(&quot;Store.txt&quot;); prop.store(w, &quot;Tips:&quot;); w.close(); &#125; private static void myLoad() throws IOException &#123; Properties prop = new Properties(); /*public void load(Reader reader):把文件中的数据读取到集合中，这个文件的数据必须是键值对形式。*/ Reader r = new FileReader(&quot;load.txt&quot;); prop.load(r); r.close(); System.out.println(&quot;prop:&quot; + prop); &#125;&#125; Properties&amp;读档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*for example*/import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.Reader;import java.io.Writer;import java.util.Properties;public class PropertiesDd &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;count.txt&quot;); if (!file.exists()) &#123; file.createNewFile(); Properties prop = new Properties(); prop.setProperty(&quot;count&quot;, &quot;0&quot;); Writer w = new FileWriter(&quot;count.txt&quot;); prop.store(w, null); w.close(); &#125; /*把数据加载到集合*/ Properties prop = new Properties(); Reader r = new FileReader(&quot;count.txt&quot;); prop.load(r); r.close(); /*已知键值对关系*/ String value = prop.getProperty(&quot;count&quot;); int number = Integer.parseInt(value); if (number &gt; 3) &#123; System.out.println(&quot;试玩结束，请付费！&quot;); System.exit(0); &#125; else &#123; number++; prop.setProperty(&quot;count&quot;, String.valueOf(number)); Writer w = new FileWriter(&quot;count.txt&quot;); prop.store(w, null); w.close(); GuessNumber.start(); &#125; &#125;&#125; NIO JDK4出现的NIO，对以前的IO操作进行了优化，但是目前还是使用以前的IO流操作…. JDK7的NIO Path:路径 Paths:通过静态方法返回一个路径。 Files:常用函数如下使用。 code–eg： 123456789101112131415161718192021222324252627import java.io.FileOutputStream;import java.io.IOException;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Paths;import java.util.ArrayList;/* * Paths:静态方法返回一个路径. * public static Path get(URI uri). * Files:静态方法. * public static long copy(Path source,OutputStream out):复制文件 * public static Path write(Path path,Iterable&lt;? extends CharSequence&gt; lines,Charset cs,OpenOption... options) */public class NIOAa &#123; public static void main(String[] args) throws IOException &#123; /* public static long copy(Path source,OutputStream out)--复制文件 */ Files.copy(Paths.get(&quot;Source.java&quot;), new FileOutputStream(&quot;Copy.java&quot;)); ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); /*Windows简体中文GBK，linux使用UTF-8*/ Files.write(Paths.get(&quot;Array.txt&quot;), array, Charset.forName(&quot;GBK&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>流 文件操作 I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归复制文件夹]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F08%2F%E9%80%92%E5%BD%92%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[随机获取文本中的名称，一行一个名称。 123456789101112131415161718192021222324252627import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.Random;/* * 要求：文本文件中存储了几个名称，写一个程序实现随机获取一个名称。 */public class GetName &#123; public static void main(String[] args) throws IOException &#123; // 把文本文件中的数据存储到集合中 BufferedReader br = new BufferedReader(new FileReader(&quot;Name.txt&quot;)); ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); String line = null; while ((line = br.readLine()) != null) &#123; array.add(line); &#125; br.close(); Random r = new Random(); int index = r.nextInt(array.size()); String name = array.get(index); System.out.println(&quot;名称为：&quot; + name); &#125;&#125; 复制单级文件夹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 要求：复制单极文件夹 数据源：E:\\Java 目的地：E:\\JavaTest*/import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyFolderDemo &#123; public static void main(String[] args) throws IOException &#123; File srcFolder = new File(&quot;E:\\Java&quot;); File destFolder = new File(&quot;E:\\JavaTest&quot;); if (!destFolder.exists()) &#123; destFolder.mkdir(); &#125; File[] fileArray = srcFolder.listFiles(); for (File file : fileArray) &#123; String name = file.getName(); File newFile = new File(destFolder, name); copyFile(file, newFile); &#125; &#125; private static void copyFile(File file, File newFile) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( file)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(newFile)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125;&#125; 复制单级文件夹&amp;改名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*for example*//*要求：复制指定目录下的指定数据类型文件，并修改后缀名。指定的文件是：.java文件。指定的后缀名是：.txt指定的目录是：TestCc数据源：E:\\Java\\*.java目的地：E:\\Jad\\*.jad */import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FilenameFilter;import java.io.IOException;public class CopyFolderDemo &#123; public static void main(String[] args) throws IOException &#123; /*File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。 */ File srcFolder = new File(&quot;E:\\Java&quot;); File destFolder = new File(&quot;E:\\Jad&quot;); if (!destFolder.exists()) &#123; destFolder.mkdir(); &#125; File[] fileArray = srcFolder.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.java&quot;); &#125; &#125;); // 遍历该File数组，得到每一个File对象. for (File file : fileArray) &#123; /* File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例。 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例。 */ String name = file.getName(); File newFile = new File(destFolder, name); copyFile(file, newFile); &#125; //改名遍历过程. File[] destFileArray = destFolder.listFiles(); for (File destFile : destFileArray) &#123; String name =destFile.getName(); //DataTypeDemo.java String newName = name.replace(&quot;.java&quot;, &quot;.jad&quot;);//DataTypeDemo.jad File newFile = new File(destFolder,newName); destFile.renameTo(newFile); &#125; System.out.println(&quot;Over!&quot;); &#125; /*文件复制函数*/ private static void copyFile(File file, File newFile) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( file)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(newFile)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125;&#125; 复制多级文件夹 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* *要求：复制多极文件夹. 数据源：E:\\JavaTest 目的地：E:\\ */import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class CopyFoldersDemo &#123; public static void main(String[] args) throws IOException &#123; File srcFile = new File(&quot;E:\\JavaTest&quot;); File destFile = new File(&quot;E:\\&quot;); copyFolder(srcFile, destFile); &#125; private static void copyFolder(File srcFile, File destFile) throws IOException &#123; if (srcFile.isDirectory()) &#123; File newFolder = new File(destFile, srcFile.getName()); newFolder.mkdir(); File[] fileArray = srcFile.listFiles(); for (File file : fileArray) &#123; copyFolder(file, newFolder); &#125; &#125; else &#123; File newFile = new File(destFile, srcFile.getName()); copyFile(srcFile, newFile); &#125; &#125; private static void copyFile(File srcFile, File newFile) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcFile)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(newFile)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>递归 文件 复制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exception&file]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F08%2Fexception%26file%2F</url>
    <content type="text"><![CDATA[exception描述：程序非正常的编译&amp;运行情况，实际使用过程中可能会出现非正常使用或者是代码逻辑上的不严谨导致的额出错。异常的处理规则是，原则上是本级处理，但是无处理语句会见exception抛到上级，直到处理。最高级别是JVM，则抛出error。 异常的分类 异常的体系 异常的处理机制 exception与runexception 由分类的层次结构图可以得知，exception是一个大类，包括了runtimexcption. 编译期间的错误是基本的语法错误，是必要进行处理的，是保证程序运行的前提。否则编译无法通过… 运行期异常可以不处理，也可以处理。处理方式一般是抛给上一级，或者使用throw new exception(). 在代码块中经常会使用到throw与throws，它们的区别是一个前置是运行期间可能的错误，是可以不处理的，如: 12345678910public static int divide(int a, int b)&#123; retuen a/b; //此处考虑到b考虑为0，则需要throw异常。&#125;public static int divide(int a, int b)&#123; if(b!=0) retuen a/b; else throw new ArithmeticException();&#125; throw存在于一个函数，抛出的是一个异常对象，“throw new ArithmeticException();”说明这里有一个异常产生了，而throws可以抛出多个异常，说明的是有可能出错，跟的是类名。 异常处理格式&amp;顺序 12345678 try...catch...finally //完全的标准异常处理格式. try...catch... try...catch...catch... try...catch...catch...fianlly try...finally ``` - 代码实例 - try...catch...作为一个完整的格式，一旦catch则异常处理完成，不继续执行相关的部分。 /**for example/ eg: try{ ... }catch(异常类名 变量名) { ... e.printStackTrace();//显示简约的异常信息. } int a = 5, b = 0; try { System.out.println(a / b); } catch (ArithmeticException ae) { System.out.println(&quot;除数不能为0&quot;); } System.out.println(&quot;over&quot;);// 可以显示出over. eg: try{ ... }catch(异常类名 变量名) { ... } catch(异常类名 变量名) { ... } int a = 10; int b = 0; int[] arr = { 1, 2, 3 }; try { System.out.println(a / b); System.out.println(arr[3]); System.out.println(&quot;testOne&quot;); } catch (ArithmeticException e) { System.out.println(&quot;testTwo&quot;); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(&quot;testThree&quot;); } catch (Exception e) { System.out.println(&quot;testFour&quot;); } System.out.println(&quot;the last.&quot;); System.out.println(&quot;over.&quot;); /*执行结果： testTwo the last. over. */ eg: try{ ... }catch(异常类名 |异常类名 变量名) { ... } try{ System.out.println(a / b); System.out.println(arr[3]); } catch (ArithmeticException | ArrayIndexOutOfBoundsException e) { System.out.println(&quot;testAa&quot;); e.printStackTrace();//显示简约的异常信息. } System.out.println(&quot;over.&quot;); /*执行结果： testAa over. */ 123- finally异常处理 - 自定义异常 继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可。 /*自定义异常抛出*/ package TestMc; import java.util.Scanner; class AaException extends Exception { public AaException() { } public AaException(String Message) { super(Message); } } class AaCheck { public void check(int a) throws AaException { if (a &lt; 0 || a &gt; 5) { throw new AaException(); } else System.out.println(&quot;输入结果无误.&quot;); } } class TestCc { public static void main(String[] args) { System.out.println(&quot;Please input your grades:&quot;); Scanner Cv = new Scanner(System.in); int Bb = Cv.nextInt(); AaCheck Ba = new AaCheck(); try { Ba.check(Bb); } catch (Exception e) { e.printStackTrace(); } System.out.println(&quot;Output Over.&quot;); } } 1234567891011121314- 继承异常的care继承的子类异常限定范围应该比父类更加小，不能比父类的异常范围更大.如： &gt;父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常。 &gt;&gt;父的方法没有异常抛出,子的重写方法不能有异常抛出。 &gt;&gt;&gt;父的方法抛出多个异常,子的重写方法必须比父少或者小。## FileJava中对I/O操作的工具类，是用来操作文件的主要类。文件和目录路径名的抽象表示：用户界面和操作系统使用依赖于系统的路径名字符串命名文件和目录。 这个类提供了一个抽象的，独立于系统的层次化路径名的视图。 - 构造方法 - 该类的构造方法有四个，得到的都是对象类型数据，具体的使用如下： File(String pathname) 根据一个路径得到File对象。 File(String parent, String child) 根据一个目录和一个子文件/目录得到File对象。 File(File parent, String child) 根据一个父File对象和一个子文件/目录得到File对象。 /*for example*/ File file = new File(&quot;e:\\demo\\a.txt&quot;); File file = new File(&quot;e:\\demo&quot;,&quot;a.txt&quot;); File file = new File(&quot;e:\\demo&quot;); File file2 = new File(file,&quot;a.txt&quot;); /*第一行==第二行==第三+第四行.*/ 12- File类文件的操作 - 创建功能 /* 创建成功返回的true，否则false.*/ public boolean createNewFile() 创建文件 如果存在这样的文件，就不创建了. /*以下两个只能创建文件夹，不能创建文件，就算是public boolean mkdir(“aa\\aa.txt”)也是创建的是aa.txt的文件夹.*/ public boolean mkdir() 创建文件夹 如果存在这样的文件夹，就不创建了. public boolean mkdirs() 创建文件夹,如果父文件夹不存在，会帮你创建出来. /*for example*/ File file = new File(&quot;e:\\demo&quot;); //在e盘目录下创建一个文件夹demo. System.out.println(&quot;mkdir:&quot; + file.mkdir()); File file = new File(&quot;e:\\demos\\aa&quot;); //在e盘目录下创建一个文件夹demos\aa. System.out.println(&quot;mkdir:&quot; + file.mkdirs()); File file = new File(&quot;e:\\demoss\\aa&quot;); //在e盘目录下创建一个文件夹demoss\aa. System.out.println(&quot;mkdir:&quot; + file.mkdir()); //无demoss创建失败. File file2 = new File(&quot;e:\\demo\\a.txt&quot;);//在e盘目录demo下创建一个文件a.txt System.out.println(&quot;createNewFile:&quot; + file2.createNewFile()); 1- 删除功能 /*删除功能:public boolean delete()*/ 如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。 Java中的删除直接从硬盘删除，不删除到回收站。 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹，含有内容则无法删除。 File file = new File(&quot;aaa\\bbb&quot;); File file2= new File(&quot;aaa&quot;); System.out.println(&quot;delete:&quot; + file6.delete()); System.out.println(&quot;delete:&quot; + file7.delete()); 12- 重命名功能 public boolean renameTo(File dest) 如果路径名相同，就是重命名，否则就是重命名&amp;&amp;剪切。 路径以盘符开始：绝对路径 如：c:\\a.txt 路径不以盘符开始：相对路径 如：a.txt，默认本位置为项目根目录。 /*for example*/ File file2 = new File(&quot;E:\\testCc.txt&quot;); File newFile2 = new File(&quot;C:\\testCa.jpg&quot;); System.out.println(&quot;renameTo:&quot; + file2.renameTo(newFile2)); 12- 判断功能 /*for example*/ public boolean isDirectory() 判断是否是目录 public boolean isFile() 判断是否是文件 public boolean exists() 判断是否存在 public boolean canRead() 判断是否可读 public boolean canWrite() 判断是否可写 public boolean isHidden() 判断是否隐藏 public class FileTest { public static void main(String[] args) { File file = new File(&quot;testCc.txt&quot;); System.out.println(&quot;isDirectory:&quot; + file.isDirectory());// false System.out.println(&quot;isFile:&quot; + file.isFile());// true System.out.println(&quot;exists:&quot; + file.exists());// true System.out.println(&quot;canRead:&quot; + file.canRead());// true System.out.println(&quot;canWrite:&quot; + file.canWrite());// true System.out.println(&quot;isHidden:&quot; + file.isHidden());// false } } 1- 获取功能 /*for example*/ public String getAbsolutePath() 获取绝对路径 public String getPath() 获取相对路径 public String getName() 获取名称 public long length() 获取长度。字节数 public long lastModified() 获取最后一次的修改时间，毫秒值，初试时间0为1970-01-01:00:00。 public class FileDemo { public static void main(String[] args) { // 创建文件对象 File file = new File(&quot;demo\\test.txt&quot;); System.out.println(&quot;getAbsolutePath:&quot; + file.getAbsolutePath()); System.out.println(&quot;getPath:&quot; + file.getPath()); System.out.println(&quot;getName:&quot; + file.getName()); System.out.println(&quot;length:&quot; + file.length()); System.out.println(&quot;lastModified:&quot; + file.lastModified()); Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String s = sdf.format(d); System.out.println(s); } } 1- 获取功能 public String[] list() 获取指定目录下的所有文件&amp;&amp;文件夹的名称，返回一个对应的String数组。 public File[] listFiles() 获取指定目录下的所有文件&amp;&amp;文件夹的File对象数组。 /*for example*/ /*获取对应文件夹下的文件名称.*/ File file = new File(&quot;C:\\&quot;); //public String[] list() String[] strArray = file.list(); for (String s : strArray) { System.out.println(s); } System.out.println(&quot;----分----割----线----&quot;); //public File[] listFiles()+getName()返回名字. File[] fileArray = file.listFiles(); for (File f : fileArray) { System.out.println(f.getName()); } 1234- 过滤功能 &gt;描述：获取指定格式文件名字，并且输出。 &gt;&gt;接口：文件名称过滤器:FilenameFilter借口。 &gt;&gt;&gt;函数如下： public String[] list(FilenameFilter filter) public File[] listFiles(FilenameFilter filter) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 &gt;&gt; /*获取ttf扩展名的文件*/--&quot;C:\\Windows\\Boot\\Fonts&quot;为测试文件路径. /*for example----普通for循环结构实现.*/ import java.io.File; public class FileTest &#123; public static void main(String[] args) &#123; File file = new File(”C:\\Windows\\Boot\\Fonts“); File[] fileArray = file.listFiles(); for (File f : fileArray) &#123; if (f.isFile()) &#123; if (f.getName().endsWith(&quot;.ttf&quot;)) &#123; System.out.println(f.getName()); &#125; &#125; &#125; &#125; &#125; /*for example----文件过滤器实现*/ import java.io.File; import java.io.FilenameFilter; public class FileTest &#123; public static void main(String[] args) &#123; File file = new File(&quot;C:\\Windows\\Boot\\Fonts&quot;); String[] strArray = file.list(new FilenameFilter() &#123; /*匿名类的使用。*/ @Override public boolean accept(File dir, String name) &#123; // return false，表示不添加; // return true,表示添加; return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.ttf&quot;); &#125; &#125;); // 遍历 for (String s : strArray) &#123; System.out.println(s); &#125; &#125; &#125;- 批量重命名 - 源文件： - 目标文件： - ![](https://i.imgur.com/nhML0s4.png) &gt;&gt; import java.io.File; public class FileDemo { public static void main(String[] args) { File srcFolder = new File(&quot;E:\\TestCc&quot;); File[] fileArray = srcFolder.listFiles(); for (File file : fileArray) { int index = name.indexOf(&quot;_&quot;); String numberString = name.substring(index + 1, index + 4); int endIndex = name.lastIndexOf(&apos;_&apos;); String nameString = name.substring(endIndex); String newName = numberString.concat(nameString); File newFile = new File(srcFolder, newName); file.renameTo(newFile); } } } ```]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>file exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[recursion&file]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F07%2Frecursion%26file%2F</url>
    <content type="text"><![CDATA[##描述： 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。 递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。 Java中使用递归注意：构造方法不能递归使用。 代码实例： 斐波那契 123456789101112131415161718192021222324252627/*for example-Fibonacci*//*思考如何用递归实现斐波那契数列的存储和显示。*/public static int fib(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; else &#123; return fib(n - 1) + fib(n - 2); &#125; &#125;/*明显的优势是将有用的数据存储在数组里面。*/arr[0] = 1;arr[1] = 1;for (int x = 2; x &lt; arr.length; x++) &#123; arr[x] = arr[x - 2] + arr[x - 1]; &#125;/*不断替换a，b对应的数据，数据不保留。*/int a = 1;int b = 1;for (int x = 0; x &lt; 18; x++) &#123; // 每运行一次将a,b对应的数据刷新一遍。 int temp = a; a = b; b = temp + b; System.out.println(a);&#125; IO流描述： 按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流… 分类： 流向 可以这样理解，流的输入还是输出性是相对于内存来描述的。相对于内存是进入内存，则为输入流–读取数据；相对于内存是流出内存，则是输出流–写出数据–写入到外部存储设备。 数据类型 字节流：字节输入流，字节输出流。 字符流：字符输入流，字符输出流。 建议使用字节流进行文件的输入和输出。 FileOutputStream写出数据 使用中，主函数必须public static void main(String[] args) throws IOException/try…catch… 1234/*for example*/ FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;); fos.write(&quot;hello,world.&quot;.getBytes()); fos.close(); FileInputStream读取数据 使用中，主函数必须public static void main(String[] args) throws IOException/try…catch… 123456789101112131415161718192021/*for example*/ FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;); //way_01: int by = 0; while((by=fis.read())!=-1) &#123; System.out.print((char)by); &#125; //way_02 char by = 0; while ((by = (char) fis.read()) != -1) &#123; System.out.print(by); &#125; //way_03 byte[] bys = new byte[1024]; int len = 0; while((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; fos.close(); 字节缓冲区流 BufferedOutputStream. BufferedInputStream. 12345678910111213141516171819202122232425262728293031323334//字符缓冲区的使用方法.public static void Way_One(String srcString, String destString) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcString)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(destString)); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close();&#125; public static void Way_Two(String srcString, String destString) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream( srcString)); BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream(destString)); int by = 0; while ((by = bis.read()) != -1) &#123; bos.write(by); &#125;fos.close();fis.close(); 字符流 Reader 12FileReaderBufferedReader Writer 12FileWriterBufferedWriter]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>recursion file</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonMark-TreeSet&Set&cCollection]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F03%2FCommonMark-TreeSet%26Set%26cCollection%2F</url>
    <content type="text"><![CDATA[注册&amp;登录 首先需要设置登录界面，进入界面后选择想进行的操作。 注册界面进入后，提示用户设置注册账户&amp;用户密码，然后将数据追加到数据库–集合，此处不考虑用户存在问题，因为程序只运行一次，注册仅有一个账户。 登录界面，提示输入账户&amp;密码，获取得到数据后遍历集合判断是否存在，存在则判断登录成功。 登录成功后可以进行其他操作，操作完成后提示是否需要退出or继续操作。 代码实例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package TestAa;import java.util.ArrayList;import java.util.Scanner;/*用户类，描述用户的相关信息.*/class user &#123; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); result = prime * result + ((password == null) ? 0 : password.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; user other = (user) obj; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; if (password == null) &#123; if (other.password != null) return false; &#125; else if (!password.equals(other.password)) return false; return true; &#125; public user() &#123; &#125; public user(String name, String password) &#123; this.name = name; this.password = password; &#125;&#125;/* 操作类，个人认为此处没有用实现接口类的必要，完全定义一个对数据库的操作类即可. */class OperatorClass &#123; // 静态修饰，随着类的加载而加载，被所有的成员所共用。 private static ArrayList&lt;user&gt; array = new ArrayList&lt;user&gt;(); // 判断登录成功与否操作. public boolean isLogin(String username, String password) &#123; boolean flag = false; for (user u : array) &#123; if (u.getName().equals(username) &amp;&amp; u.getPassword().equals(password)) &#123; flag = true; break; &#125; &#125; return flag; &#125; // 注册操作，添加至集合. public void regist(user user) &#123; array.add(user); &#125;&#125;class application &#123; public static void start() &#123; System.out.println("游戏开始了."); &#125; public static void end() &#123; System.out.println("游戏结束了."); &#125; public application() &#123; super(); &#125;&#125;/* 主类，对效果进行操作，也称之为测试类. */public class regist_Log &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub // 限制循环次数，不使用while是确定正常用户操作的特性. for (int Cast = 0; Cast &lt; 30; ++Cast) &#123; System.out.println("--------------------用户主界面--------------------"); System.out.println("1:\t用户注册"); System.out.println("2:\t用户登录"); System.out.println("3:\t用户退出"); Scanner sc = new Scanner(System.in); System.out.println("请选择你想进行的操作："); String lineAa = sc.nextLine(); OperatorClass Operator = new OperatorClass(); // 登录主界面 switch (lineAa) &#123; case "1": // 注册界面 System.out.println("----------------注册界面----------------"); System.out.println("请输入用户名："); String userName = sc.nextLine(); System.out.println("请输入密码："); String passWord = sc.nextLine(); user user = new user(userName, passWord); Operator.regist(user); System.out.println("注册成功"); break; case "2": // 登录界面，请输入用户名和密码 for (int count = 0; count &lt; 3;) &#123; System.out.println("----------------登录界面----------------"); System.out.println("请输入用户名："); String username = sc.nextLine(); System.out.println("请输入密码："); String password = sc.nextLine(); boolean flag = Operator.isLogin(username, password); if (flag) &#123; System.out.println("登录成功,可以开始操作了."); System.out.println("继续么？y/n"); while (true) &#123; String continueAa = sc.nextLine(); if (continueAa.equalsIgnoreCase("y")) &#123; application.start(); System.out.println("你还玩吗?y/n"); &#125; else &#123; break; &#125; &#125; System.out.println("欢迎下次再来."); System.exit(0); &#125; else &#123; System.out.println("登录失败."); ++count; &#125; if (count == 3) System.exit(0); &#125; break; case "3": System.out.println("谢谢使用，欢迎下次再来"); System.exit(0); default: break; &#125; &#125; &#125;&#125; Set集合描述：是一个Collection的子接口，对比于Collection子接口List。前者为不重复元素的集合，后者为可以重复元素的集合。 Set集合的特点： 无序&amp;唯一。 HashSet集合：描述：底层数据结构是哈希表-链表数组。要实现数据的唯一性，其使用：hashCode()和equals()两个方法。执行顺序： 1234567if hashcode相同 if 内容相同 元素存在 else 追加到集合else 追加到集合. 关于hashcode&amp;equals使用自动生成即可。 代码实例 实例一：HashSet存储字符串并遍历 123456789101112public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;hello&quot;); set.add(&quot;Jack&quot;); set.add(&quot;world&quot;); set.add(&quot;Jack&quot;); set.add(&quot;world&quot;); // 增强for for (String s : set) &#123; System.out.println(s); &#125;&#125; 实例二：HashSet存储自定义对象并遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package TestAa;import java.util.HashSet;import java.util.Set;class animal &#123; private String name; private int age; public animal() &#123; super(); // TODO Auto-generated constructor stub &#125; public animal(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; animal other = (animal) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return &quot;animal [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125;public class CompareBb &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Set&lt;animal&gt; animalSet = new HashSet&lt;animal&gt;(); animalSet.add(new animal(&quot;Tom&quot;, 5)); animalSet.add(new animal(&quot;Tom&quot;, 5)); animalSet.add(new animal(&quot;Jack&quot;, 5)); animalSet.add(new animal(&quot;Jack&quot;, 4)); animalSet.add(new animal(&quot;Rose&quot;, 5)); animalSet.add(new animal(&quot;Rose&quot;, 3)); System.out.println(&quot;animalSet:&quot; + animalSet); for (animal temp : animalSet) &#123; System.out.println(&quot;name:&quot; + temp.getName() + &quot;\tage:&quot; + temp.getAge()); &#125; &#125;&#125; LinkedHashSet LinkedHashSet:底层数据结构由哈希表和链表组成。 哈希表保证元素的唯一性。 链表保证元素有素,由于数据的存储在底部一定是按照一定的顺序记录的，一般指数据的有序性指的是输出输入顺序不会发生改变。 代码实例： 123456789101112131415import java.util.LinkedHashSet;public class LinkedHashSetCc &#123; public static void main(String[] args) &#123; LinkedHashSet&lt;String&gt; hs = new LinkedHashSet&lt;String&gt;(); hs.add(&quot;hello&quot;); hs.add(&quot;world&quot;); hs.add(&quot;Tom&quot;); hs.add(&quot;world&quot;); for (String s : hs) &#123; System.out.println(s); &#125; &#125;&#125; TreeSet 底层数据结构是红黑树-是一个自平衡的二叉树-数据结构中描述为二叉排序树。 元素排序实现 自然排序：元素本身可以比较，让元素所属的类实现Comparable接口 1234567891011121314/*for example*/ public static void main(String[] args) &#123; // 创建集合对象 // 自然顺序进行排序 TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); ts.add(20); ts.add(18); ts.add(22); ts.add(19); ts.add(24); for (Integer i : ts) &#123; System.out.println(i); &#125; &#125; 比较器排序：集合具备比较性，让集合构造方法接收Comparator的实现类对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*此为也为Compareable的实现方式.*/package TestAa;import java.util.TreeSet;/*如果一个类的元素要想能够进行自然排序，就必须实现自然排序接口Comparable*/class animalCc implements Comparable&lt;animalCc&gt; &#123; private String name; private int age; public animalCc() &#123; &#125; public animalCc(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override /* 关键性代码块. */ public int compareTo(animalCc arg0) &#123; // 规则为树的插入排序，小走左边，大走右边，相同则不添加。 // return -1;添加顺序的逆序排 // return 1;添加顺序的顺序排. // return 0; 自动生成的默认参数为0，其意思是与比较元素完全相同，所以元素只存储一个 /* * 设置排序规则：如：第一规则为年龄，，升序，其余自己分析，保证数据不丢失。 */ /* 判断，年龄。 */ int num1 = this.age - arg0.age; /* 判断姓名 */ int num2 = num1 == 0 ? this.name.compareTo(arg0.name) : num1; return num2; &#125;&#125;public class TreeObject &#123; public static void main(String[] args) &#123; TreeSet&lt;animalCc&gt; ts = new TreeSet&lt;animalCc&gt;(); animalCc s1 = new animalCc(&quot;Tom&quot;, 27); animalCc s2 = new animalCc(&quot;Jack&quot;, 29); animalCc s3 = new animalCc(&quot;Jack&quot;, 23); animalCc s4 = new animalCc(&quot;Coffee&quot;, 27); animalCc s5 = new animalCc(&quot;Tom&quot;, 22); animalCc s6 = new animalCc(&quot;Jack&quot;, 29); animalCc s7 = new animalCc(&quot;Tom&quot;, 22); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.add(s6); ts.add(s7); for (animalCc s : ts) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; &#125;&#125; 代码实例：比较器排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 /*集合具备比较性, 让集合的构造方法接收一个比较器接口的子类对象 Comparator /*for example*/ class student&#123; 成员变量 成员方法 构造方法 标准代码块部分. &#125; /*构造一个比较器接口的子类对象.*/ import java.util.Comparator; public class MyComparator implements Comparator&lt;Student&gt; &#123; public int compare(Student s1, Student s2) &#123; // int num = this.name.length() - s.name.length(); // this -- s1 // s -- s2 // 姓名长度 int num = s1.getName().length() - s2.getName().length(); // 姓名内容 int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num; // 年龄 int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2; return num3; &#125; &#125; /*测试组部分*/ public class TreeSetDemo &#123; public static void main(String[] args) &#123; /*匿名内部类对其实现，无需要新建一个实现比较器接口的子类。-上部分也可以直接省略.*/ TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; // 姓名长度 int num = s1.getName().length() - s2.getName().length(); // 姓名内容 int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num; // 年龄 int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2; return num3; &#125; &#125;); // 创建元素 Student s1 = new Student(&quot;linqingxia&quot;, 27); Student s2 = new Student(&quot;zhangguorong&quot;, 29); Student s3 = new Student(&quot;wanglihong&quot;, 23); Student s4 = new Student(&quot;linqingxia&quot;, 27); Student s5 = new Student(&quot;liushishi&quot;, 22); Student s6 = new Student(&quot;wuqilong&quot;, 40); Student s7 = new Student(&quot;fengqingy&quot;, 22); Student s8 = new Student(&quot;linqingxia&quot;, 29); // 添加元素 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.add(s6); ts.add(s7); ts.add(s8); // 遍历 for (Student s : ts) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125; &#125; &#125; ``` ### Collection集合总结- Collection子类结构![](https://i.imgur.com/YeeWkSJ.png)- Collection集合使用 if Uniqueness Set if Sort TreeSet else HashSet Default HashSet. else List if Safety Vector esle ArrayList or LinkedList Inquire：ArrayList add/del：LinkedList Default ArrayList。 Default ArrayList. if Collection ArrayList. ` 数据结构选择]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>Java Colletion Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection&Ma&Poker]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F03%2FCollection%26Ma%26Poker%2F</url>
    <content type="text"><![CDATA[Map描述： 键映射到值的对象, 地图不能包含重复的键; 每个键可以映射到最多一个值。这个接口取代了Dictionary类，它是一个完全抽象的类而不是接口。 Map&amp;Collection区别 Map 存储的是键值对形式的元素，键唯一，值可以重复。 Collection 存储的是单独出现的元素，子接口Set元素唯一，子接口List元素可重复。 Map接口功能 添加功能 1234567V put(K key,V value):添加元素。 若存在则返回更新之前的value值，不存在返回NULL，且属于可选择返回：可以返回，也可以不返回。/*for example*/Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();System.out.println(map.put("Tom", "2")); //NULLSystem.out.println(map.put("Tom", "3")); //2 删除功能 123void clear():移除所有的键值对元素.V remove(Object key)：根据键删除键值对元素,并把值返回.System.out.println(&quot;remove:&quot; + map.remove(&quot;Tom)); //3 判断功能 123boolean containsKey(Object key)：判断集合是否包含指定的键.boolean containsValue(Object value):判断集合是否包含指定的值.boolean isEmpty()：判断集合是否为空. 获取功能 123456789101112131415161718192021222324Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():返回键值对. /*for example*/ Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();V get(Object key):根据键获取值. /*for example*/ System.out.println(&quot;get:&quot; + map.get(&quot;Tom&quot;)); //显示3.Set&lt;K&gt; keySet():获取集合中所有键的集合. /*for example*/ Set&lt;String&gt; set = map.keySet();Collection&lt;V&gt; values():获取集合中所有值的集合. /*for example*/ Collection&lt;String&gt; con = map.values();/*conclusion*/Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;String, String&gt; Aa : set) &#123; String key = Aa.getKey(); String value = Aa.getValue(); System.out.println(key + &quot;---&quot; + value); &#125; 长度功能 123int size()：返回集合中的键值对的对数. /*for example*/ System.out.println(&quot;size:&quot;+map.size()); Map集合的遍历 键-&gt;值. 12345678/*for example*/Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); Set&lt;String&gt; set = map.keySet(); for (String key : set) &#123; String value = map.get(key); System.out.println(key + &quot;---&quot; + value); &#125; 键值对-&gt;找键和值 123456789101112 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet(); /*遍历键值对*/ for (Map.Entry&lt;String, String&gt; me : set) &#123; String key = me.getKey(); String value = me.getValue(); System.out.println(key + &quot;---&quot; + value); &#125; ``` - HashMap集合 - HashMap&lt;String,String&gt; HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); -键值对添加区域- //hm.put(&quot;key&quot;,&quot;value&quot;) /*遍历*/ Set&lt;String&gt; set = hm.keySet(); for (String key : set) { String value = hm.get(key); System.out.println(key + &quot;---&quot; + value); } 1- HashMap&lt;Integer,String&gt; HashMap&lt;Integer, String&gt; hm = new HashMap&lt;Integer, String&gt;(); -键值对添加区域- //hm.put(key,&quot;value&quot;) // 遍历 Set&lt;Integer&gt; set = hm.keySet(); for (Integer key : set) { String value = hm.get(key); System.out.println(key + &quot;---&quot; + value); } 1- HashMap&lt;String,Student&gt; HashMap&lt;String, Student&gt; hm = new HashMap&lt;String, Student&gt;(); -键值对添加区域- //hm.put(&quot;key&quot;,value) value=objecet对象，如student. // 遍历 Set&lt;String&gt; set = hm.keySet(); for (String key : set) { Student value = hm.get(key); System.out.println(key + &quot;---&quot; + value.getName() + &quot;---&quot; + value.getAge()); } 12- HashMap&lt;Student,String&gt; HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;(); -键值对添加区域- //hm.put(value,&quot;key&quot;) value=objecet对象，如student. // 遍历 Set&lt;Student&gt; set = hm.keySet(); for (Student key : set) { String value = hm.get(key); System.out.println(key.getName() + &quot;---&quot; + key.getAge() + &quot;---&quot; + value); } 1234- TreeMap集合- TreeMap&lt;String,String&gt; TreeMap&lt;String, String&gt; tm = new TreeMap&lt;String, String&gt;(); -键值对添加区域- //hm.put(&quot;key&quot;,&quot;value&quot;) // 遍历集合 Set&lt;String&gt; set = tm.keySet(); for (String key : set) { String value = tm.get(key); System.out.println(key + &quot;---&quot; + value); } 1- TreeMap&lt;Student,String&gt; /for example/ /自动生成学生类/ public class Student { private String name; private int age; public Student() { super(); } public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } /测试主类/ import java.util.Comparator; import java.util.Set; import java.util.TreeMap; /TreeMap&lt;Student,String&gt;/ public class TreeMapMain { public static void main(String[] args) { //匿名抽象借口重写 TreeMap&lt;Student, String&gt; tm = new TreeMap&lt;Student, String&gt;( new Comparator&lt;Student&gt;() { @Override public int compare(Student s1, Student s2) { //第一个变量-第二个=升序排列. // 优先级年龄 int num = s1.getAge() - s2.getAge(); // 优先级名字 int num2 = num == 0 ? s1.getName().compareTo( s2.getName()) : num; return num2; } }); Student s1 = new Student(&quot;Aa&quot;, 30); Student s2 = new Student(&quot;Bb&quot;, 35); Student s3 = new Student(&quot;Cc&quot;, 33); Student s4 = new Student(&quot;Dd&quot;, 32); Student s5 = new Student(&quot;Ee&quot;, 33); tm.put(s1, &quot;01&quot;); tm.put(s2, &quot;02&quot;); tm.put(s3, &quot;03&quot;); tm.put(s4, &quot;04&quot;); tm.put(s5, &quot;05&quot;); // 遍历 Set&lt;Student&gt; set = tm.keySet(); for (Student key : set) { String value = tm.get(key); System.out.println(key.getName() + &quot;---&quot; + key.getAge() + &quot;---&quot; + value); } } } 12- 多层嵌套 - hashMap&amp;hashMap /*for example*/ //注意导包:Ctrl+Shift+O package TestAa; import java.util.HashMap; import java.util.Set; public class HashMapHashMap { public static void main(String[] args) { HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; bigMap = new HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;(); // 子图一 HashMap&lt;String, Integer&gt; oneMap = new HashMap&lt;String, Integer&gt;(); oneMap.put(&quot;Tom&quot;, 5); oneMap.put(&quot;Jack&quot;, 2); bigMap.put(&quot;one&quot;, oneMap); // 子图二 HashMap&lt;String, Integer&gt; twoMap = new HashMap&lt;String, Integer&gt;(); twoMap.put(&quot;John&quot;, 3); twoMap.put(&quot;Suqi&quot;, 4); bigMap.put(&quot;two&quot;, twoMap); // 遍历集合 Set&lt;String&gt; bigMapSet = bigMap.keySet(); for (String bigMapKey : bigMapSet) { System.out.println(bigMapKey); HashMap&lt;String, Integer&gt; bigMapValue = bigMap.get(bigMapKey); Set&lt;String&gt; sonMapSet = bigMapValue.keySet(); for (String sonValue : sonMapSet) { Integer value = bigMapValue.get(sonValue); System.out.println(&quot;\t&quot; + sonValue + &quot;---&quot; + value); } } } } 12- 统计字符串字母频数 public class TreeMap{ public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String line = sc.nextLine(); TreeMap&lt;Character, Integer&gt; tm = new TreeMap&lt;Character, Integer&gt;(); char[] chs = line.toCharArray(); for(char ch : chs){ Integer i = tm.get(ch); if(i == null){ tm.put(ch, 1); }else { i++; tm.put(ch,i); } } StringBuilder sb= new StringBuilder(); Set&lt;Character&gt; set = tm.keySet(); for(Character key : set){ Integer value = tm.get(key); sb.append(key).append(&quot;(&quot;).append(value).append(&quot;)&quot;); } String result = sb.toString(); System.out.println(&quot;result:&quot;+result); } } 123456789101112- 忽略以下. - HashMap嵌套ArrayList - ArrayList嵌套HashMap - 多层嵌套 ## Collections描述：注意与collection的区别,是针对集合进行操作的工具类.- Collection&amp;Collections差异 - Collection 是单列集合的顶层接口，有两个子接口List和Set. - Collections 是针对集合进行操作的工具类，可以对集合进行排序和查找等.- 常用函数 - public static &lt;T&gt; void sort(List&lt;T&gt; list) List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(value); //value为Integer数据类型. Collections.sort(list); 1- public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key) /*二分查找法，返回Index，未找到为-[(List.size)+1]*/ System.out.println(&quot;binarySearch:&quot; + Collections.binarySearch(list, 60)); 1- public static &lt;T&gt; T max(Collection&lt;?&gt; coll) /*for example，获取最大值.*/ System.out.println(&quot;max:&quot; + Collections.max(list)); 1- public static void reverse(List&lt;?&gt; list) Collections.reverse(list); //List反转 System.out.println(&quot;list:&quot; + list); 1- public static void shuffle(List&lt;?&gt; list) Collections.shuffle(list); //List随机打乱. System.out.println(&quot;list:&quot; + list); 12- 代码实例： - ArrayList对象排序 public class CollectionsDemo { public static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); - 添加对象数据区域- - // Collections.sort(list); // 比较器排序，如果同时有自然排序和比较器排序，以比较器排序为主 Collections.sort(list, new Comparator&lt;Student&gt;() { @Override public int compare(Student s1, Student s2) { int num = s2.getAge() - s1.getAge(); int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num; return num2; } }); for (Student s : list) { System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } } } 12- 斗地主洗牌&amp;发牌&amp;排序-(来源于网上.) package cn.itcast_04; import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.TreeSet; /* * 思路： * A:创建一个HashMap集合 * B:创建一个ArrayList集合 * C:创建花色数组和点数数组 * D:从0开始往HashMap里面存储编号，并存储对应的牌 * 同时往ArrayList里面存储编号即可。 * E:洗牌(洗的是编号) * F:发牌(发的也是编号，为了保证编号是排序的，就创建TreeSet集合接收) * G:看牌(遍历TreeSet集合，获取编号，到HashMap集合找对应的牌) */ public class PokerDemo { public static void main(String[] args) { // 创建一个HashMap集合 HashMap&lt;Integer, String&gt; hm = new HashMap&lt;Integer, String&gt;(); // 创建一个ArrayList集合 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // 创建花色数组和点数数组 // 定义一个花色数组 String[] colors = { &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot; }; // 定义一个点数数组 String[] numbers = { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;, }; // 从0开始往HashMap里面存储编号，并存储对应的牌,同时往ArrayList里面存储编号即可。 int index = 0; for (String number : numbers) { for (String color : colors) { String poker = color.concat(number); hm.put(index, poker); array.add(index); index++; } } hm.put(index, &quot;小王&quot;); array.add(index); index++; hm.put(index, &quot;大王&quot;); array.add(index); // 洗牌(洗的是编号) Collections.shuffle(array); // 发牌(发的也是编号，为了保证编号是排序的，就创建TreeSet集合接收) TreeSet&lt;Integer&gt; fengQingYang = new TreeSet&lt;Integer&gt;(); TreeSet&lt;Integer&gt; linQingXia = new TreeSet&lt;Integer&gt;(); TreeSet&lt;Integer&gt; liuYi = new TreeSet&lt;Integer&gt;(); TreeSet&lt;Integer&gt; diPai = new TreeSet&lt;Integer&gt;(); for (int x = 0; x &lt; array.size(); x++) { if (x &gt;= array.size() - 3) { diPai.add(array.get(x)); } else if (x % 3 == 0) { fengQingYang.add(array.get(x)); } else if (x % 3 == 1) { linQingXia.add(array.get(x)); } else if (x % 3 == 2) { liuYi.add(array.get(x)); } } // 看牌(遍历TreeSet集合，获取编号，到HashMap集合找对应的牌) lookPoker(&quot;风清扬&quot;, fengQingYang, hm); lookPoker(&quot;林青霞&quot;, linQingXia, hm); lookPoker(&quot;刘意&quot;, liuYi, hm); lookPoker(&quot;底牌&quot;, diPai, hm); } // 写看牌的功能 public static void lookPoker(String name, TreeSet&lt;Integer&gt; ts, HashMap&lt;Integer, String&gt; hm) { System.out.print(name + &quot;的牌是：&quot;); for (Integer key : ts) { String value = hm.get(key); System.out.print(value + &quot; &quot;); } System.out.println(); } } ```]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>Collection Ma Poker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List&泛型]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F11%2F02%2FGitHub-List%26%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[List list子类及其特性 ArrayList: 底层数据结构是数组，查询快，增删慢，线程不安全，效率高。 12345678910111213141516171819202122/*for example*/ public static void main(String[] args) &#123; ArrayList array = new ArrayList(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); Rem：1 // array.add(new Integer(100));// 标准写法 //array.add(10); // JDK5以后的自动装箱,等价于：array.add(Integer.valueOf(10)); Iterator it = array.iterator(); while (it.hasNext()) &#123; Rem：1，若使用Rem处代码，强转数据类型： // String s = (String) it.next(); 则： // ClassCastException String s = (String) it.next(); System.out.println(s); /*代码黄色警告线，因为事先不指定的数据类型，若添加的数据类型不一致，强转后抛出ClassCaseExcpetion异常，为隐患使用方法.*/ &#125; Vector: 底层数据结构是数组，查询快，增删慢，线程安全，效率低。 由于集合是JDK1.2后才有的特性，所以针对出现在JKD1.0的Vector本身有自己的添加获取功能，但是可以使用父类ArrayList对应功能所代替。 /*1.0版本的本身独有功能：*/ 添加：public void addElement(E obj) -- add() 获取：public E elementAt(int index) -- get() public Enumeration&lt;E&gt; elements() -- iterator() 代码实例： 12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; Vector v = new Vector(); v.addElement(&quot;hello&quot;); v.addElement(&quot;world&quot;); for (int x = 0; x &lt; v.size(); x++) &#123; String s = (String) v.elementAt(x); System.out.println(s); &#125; System.out.println(&quot;------------------&quot;); Enumeration en = v.elements(); while (en.hasMoreElements()) &#123; String s = (String) en.nextElement(); System.out.println(s); &#125; &#125;``` - LinkedList: 底层数据结构是链表，查询慢，增删快，线程不安全，效率高。由于其有不同的底层结构所有也有特有函数。``` 添加： public void addFirst() //表头添加，头插法. public void addLast() //表尾添加，尾插法. 删除 public Object removeFirst() //删除第一个节点. public Object removeLast() //删除第二个节点. 获取 public Object getFirst() //获取第一个节点. public Object getLast() //获取最后一个节点. 代码实例 12345678910111213141516171819202122232425public static void main(String[] args) &#123; LinkedList link = new LinkedList(); link.add(&quot;hello&quot;); //后面追加. link.add(&quot;world&quot;); // public void addFirst(Object e) // public void addLast(Object e) // public Object getFirst() // System.out.println(&quot;getFirst:&quot; + link.getFirst()); // public Obejct getLast() // System.out.println(&quot;getLast:&quot; + link.getLast()); // public Object removeFirst() System.out.println(&quot;removeFirst:&quot; + link.removeFirst()); // public Object removeLast() System.out.println(&quot;removeLast:&quot; + link.removeLast()); // 输出对象名，tostring(),返回对象内容。 System.out.println(&quot;link:&quot; + link); &#125;``` - 总结 - 遍历字符串集合，仅保留重复元素的其中一个。 public static void main(String[] args) { // TODO Auto-generated method stub ArrayList arrayStr = new ArrayList(); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;luck&quot;); arrayStr.add(&quot;tom&quot;); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;luck&quot;); arrayStr.add(&quot;tom&quot;); Iterator It = arrayStr.iterator(); ArrayList NewArrayStr = new ArrayList(); /* Method:the first */ while (It.hasNext()) { String temp = (String) It.next(); if (!(NewArrayStr.contains(temp))) { NewArrayStr.add(temp); } } System.out.println(&quot;Result:&quot; + NewArrayStr); System.out.println(&quot;******this is dividing line******&quot;); /* Method:the second */ for (int x = 0; x &lt; arrayStr.size() - 1; ++x) { for (int y = x + 1; y &lt; arrayStr.size(); ++y) { if (arrayStr.get(x).equals(arrayStr.get(y))) { arrayStr.remove(y); // 目的是为了解决相同元素，叠上来的时候造成数据漏检。 y--; } } } System.out.println(&quot;Result:&quot; + arrayStr); } 12 - 遍历对象集合，仅保留重复元素的其中一个。 package TestAa; import java.util.ArrayList; import java.util.Iterator; class Animal { private int age; private String name; public Animal() { super(); // TODO Auto-generated constructor stub } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Animal(String name, int age) { super(); this.age = age; this.name = name; } @Override public String toString() { // TODO Auto-generated method stub return this.getName() + &quot;:&quot; + this.getAge(); } // contain使用的是equal方法，所以需要重写equal方法。 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Animal other = (Animal) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } public class CompareAa { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub ArrayList arrayList = new ArrayList(); Animal animal1 = new Animal(&quot;Tom&quot;, 3); Animal animal2 = new Animal(&quot;Jack&quot;, 5); Animal animal3 = new Animal(&quot;Tom&quot;, 2); Animal animal4 = new Animal(&quot;Tom&quot;, 3); Animal animal5 = new Animal(&quot;Jack&quot;, 5); Animal animal6 = new Animal(&quot;Tom&quot;, 2); Animal animal7 = new Animal(&quot;Tom&quot;, 2); Animal animal8 = new Animal(&quot;Jack&quot;, 5); Animal animal9 = new Animal(&quot;Tom&quot;, 2); arrayList.add(animal1); arrayList.add(animal2); arrayList.add(animal3); arrayList.add(animal4); arrayList.add(animal5); arrayList.add(animal6); arrayList.add(animal7); arrayList.add(animal8); arrayList.add(animal9); /* method:the first... */ Iterator it = arrayList.iterator(); ArrayList newArray = new ArrayList(); while (it.hasNext()) { Animal tempCc = (Animal) it.next(); if (!(newArray.contains(tempCc))) newArray.add(tempCc); } System.out.println(newArray); System.out.println(&quot;*****this is a dividing line******&quot;); /* method:the second... */ for (int x = 0; x &lt; arrayList.size() - 1; ++x) { for (int y = x + 1; y &lt; arrayList.size(); ++y) { if (arrayList.get(x).equals(arrayList.get(y))) { arrayList.remove(y); // 目的是为了解决相同元素漏检的问题。 y--; } } } System.out.println(arrayList); } } 12 - 用LinkedList模拟栈结构。 package TestAa; import java.util.LinkedList; class StackCc { private LinkedList linkCc; public StackCc() { linkCc = new LinkedList(); // TODO Auto-generated constructor stub } public Object popCc() { return linkCc.removeFirst(); } public void pushCc(Object obj) { linkCc.addFirst(obj); } @Override public String toString() { return &quot;StackCc [linkCc=&quot; + linkCc + &quot;]&quot;; } } public class CompareAa { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub StackCc Cc = new StackCc(); Cc.pushCc(&quot;hello&quot;); Cc.pushCc(&quot;world&quot;); System.out.println(Cc); System.out.println(&quot;******this is a dividing line******&quot;); Cc.popCc(); Cc.popCc(); System.out.println(Cc); } } 1234567891011### 泛型是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型，可以理解为一个程序的模版，在需要的时候才将所需要的数据类型填入其中，而在模版需要数据类型的位置需要添加一个占位标记符号&lt;&gt;，&lt;font size = 3, color = 0X6FFF&gt;该数据类型只能是引用类型&lt;/font&gt;。- 出现时间：JDK1.5- 特点： - 把运行时期的问题提前到了编译期间 - 避免了强制类型转换 - 优化了程序设计，解决了黄色警告线问题，让程序更安全，上诉的所有代码都有黄色警告，而使用泛型可以解决该问题，比如：已经确定ArrayList数据类型是String，防止list(new Integer(100))，导致下面强转时候报错。 - 安全性描述：早期的时候，我们使用Object来代表任意的类型，因为其为超类，是类的父类，但是实际使用的时候其实是限制了数据类型了，不能任意的转化，只能转化为本身，这就是存在的安全隐患，也就是警告提示的原因。 也就是说这样的程序其实并不是安全的。所以Java在JDK5后引入了泛型，提高程序的安全性。 - 代码实例 - 泛型&amp;String数据类型 /for example/public static void main(String[] args) { //创建对象时候指定添加到数据类型就是String数据类型。 ArrayList array = new ArrayList(); array.add(“hello”); array.add(“world”); Iterator it = array.iterator(); while (it.hasNext()) { String s = it.next(); System.out.println(s); System.out.println(“——–this is a dividing ling——–”); for (String Cc : array) { System.out.println(Cc); } System.out.println(“——-this is a dividing ling——-“); for (int x = 0; x &lt; array.size(); ++x) { System.out.println(array.get(x)); }}/ 泛型就是事先确定数据类型，不能具体确定的数据类型就使用占位符-通配符描述。/ 12- 泛型&amp;对象数据类型 /数据对象类型为对象类的遍历实现/ package TestAa; import java.util.ArrayList; import java.util.Iterator; class Animal { private String name; private int age; public Animal(String name, int age) { super(); this.name = name; this.age = age; } public Animal() { super(); // TODO Auto-generated constructor stub } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } public class CompareAa { /** * @param args */ public static void main(String[] args) { // JDK7的新特性：泛型推断。 // ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();不会报错也不会警告，但是不建议这样使用。 ArrayList&lt;Animal&gt; array = new ArrayList&lt;&gt;(); Animal s1 = new Animal(&quot;Tom&quot;, 4); Animal s2 = new Animal(&quot;Jack&quot;, 2); Animal s3 = new Animal(&quot;Coffe&quot;, 5); array.add(s1); array.add(s2); array.add(s3); Iterator&lt;Animal&gt; it = array.iterator(); while (it.hasNext()) { Animal s = it.next(); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } System.out.println(&quot;------this is a dividing line------&quot;); for (int x = 0; x &lt; array.size(); x++) { Animal s = array.get(x); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } System.out.println(&quot;------this is a dividing line------&quot;); for (Animal s : array) { System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } } } 1234- 类别 - 泛型类 / for example//该段在编译时候不会报错也不会警告，但是运行错误，原因是类型转化问题/public class ObjectTool { private Object obj; public Object getObj() { return obj; } public void setObj(Object obj) { // Object obj = new Integer(30); this.obj = obj; } }public class ObjectToolDemo { public static void main(String[] args) { ObjectTool ot = new ObjectTool(); // 运行正常。 ot.setObj(new Integer(2)); Integer i = (Integer) ot.getObj(); System.out.println(&quot;年龄是：&quot; + i); ot.setObj(new String(&quot;Tom&quot;)); String s = (String) ot.getObj(); System.out.println(&quot;姓名是：&quot; + s); System.out.println(&quot;---------&quot;); ot.setObj(new Integer(2)); // 报错，类型转换错误，ClassCastException String ss = (String) ot.getObj(); System.out.println(&quot;姓名是：&quot; + ss); } }System.out.println(“——-this is a dividing line———“);/泛型解决方案/public class ObjectTool { private T obj; public T getObj() { return obj; } public void setObj(T obj) { this.obj = obj; } }public class ObjectToolDemo { public static void main(String[] args) { ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); ot.setObj(new String(&quot;Tom&quot;)); String s = ot.getObj(); System.out.println(&quot;姓名是：&quot; + s); ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); // ot2.setObj(new String(&quot;Jack&quot;));//这个时候编译期间就过不去 ot2.setObj(new Integer(27)); Integer i = ot2.getObj(); System.out.println(&quot;年龄是：&quot; + i); } }12- 泛型方法 public class ObjectTool { public void show(T t) { System.out.println(t); }}public class ObjectToolDemo { public static void main(String[] args) { // 定义到泛型方法后，可以接受任意数据类型。 ObjectTool ot = new ObjectTool(); ot.show(“hello”); ot.show(100); ot.show(true); }}1- 泛型接口 public interface Inter&lt;T&gt; { public abstract void show(T t); } /*第一种：实现类在实现接口的时候已经知道数据类型*/ public class InterImpl implements Inter&lt;String&gt; { @Override public void show(String t) { System.out.println(t); } } //第二种情况：还不知道数据类型. public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; { @Override public void show(T t) { System.out.println(t); } } public static void main(String[] args) { /*第一种*/ Inter&lt;String&gt; i = new InterImpl(); i.show(&quot;hello&quot;); /*第二种情况的测试*/ Inter&lt;String&gt; i = new InterImpl&lt;String&gt;(); i.show(&quot;hello&quot;); Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;(); ii.show(100); } 1234567- 泛型高级通配符 - ? - ? extends E - ? super E - 代码实例 /*for example*/ public class GenericDemo { public static void main(String[] args) { // 泛型如果明确的写的时候，前后必须一致 Collection&lt;Object&gt; c1 = new ArrayList&lt;Object&gt;(); // Collection&lt;Object&gt; c2 = new ArrayList&lt;Animal&gt;(); 报错 // ?表示任意的类型都是可以的 Collection&lt;?&gt; c5 = new ArrayList&lt;Object&gt;(); Collection&lt;?&gt; c6 = new ArrayList&lt;Animal&gt;(); // ? extends E:向下限定，E及其子类 // Collection&lt;? extends Animal&gt; c9 = new ArrayList&lt;Object&gt;(); Collection&lt;? extends Animal&gt; c10 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; c11 = new ArrayList&lt;Dog&gt;(); // ? super E:向上限定，E极其父类 Collection&lt;? super Animal&gt; c13 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; c14 = new ArrayList&lt;Animal&gt;(); // Collection&lt;? super Animal&gt; c15 = new ArrayList&lt;Dog&gt;(); } } class Animal { } class extends Dog{ } 1234 ### 增强for循环一种简化的for循环结构。- 格式 for(DataType Variable : Collection/Object){ Variable in Array/Collection.}12345 ### 可变参数Arrays工具下一个函数：static &lt;T&gt; List&lt;T&gt; asList(T... a) 返回由指定数组支持的固定大小的列表。 - List list = Arrays.asList(“hello”, “world”); // UnsupportedOperationException // list.add(“NewDay”); // UnsupportedOperationException // list.remove(NewLife); list.set(1, “Test”); for (String s : list) { System.out.println(s); } } 123### 集合嵌套遍历- 实例一 /for example,二层嵌套/public class CollectionCc { public static void main(String[] args) { // 最外层集合 ArrayList&lt;ArrayList&lt;Animal&gt;&gt; bigArrayList = new ArrayList&lt;ArrayList&lt;Animal&gt;&gt;(); //创建对应的所有对象，分别添加进组，再小组进大组。 ArrayList&lt;Animal&gt; firstArrayList = new ArrayList&lt;Student&gt;(); bigArrayList.add(firstArrayList); ArrayList&lt;Animal&gt; secondArrayList = new ArrayList&lt;Student&gt;(); bigArrayList.add(secondArrayList); ArrayList&lt;Animal&gt; thirdArrayList = new ArrayList&lt;Student&gt;(); bigArrayList.add(thirdArrayList); // 遍历集合 for (ArrayList&lt;Animal&gt; array : bigArrayList) { for (Student s : array) { System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } } } }12- 实例二 /获取1-100随机数/public static void main(String[] args) { Random r = new Random(); //泛型集合 ArrayList&lt;Integer&gt; arrayCc = new ArrayList&lt;Integer&gt;(); int count = 0; while (count &lt; 10) { int number = r.nextInt(20) + 1; if(!arrayCc.contains(number)){ //如果不存在:就添加，统计变量++。 arrayCc.add(number); count++; } } //增强for遍历. for(Integer i : array){ System.out.println(i); } System.out.println(array); } 12- 实例三 /*for example*/ /*获取键盘输入的不确定个数的最大值.*/ public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 数据不确定的情况下。只能是用集合存储，翻新保证程序的健壮性. ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // 设置结束符号，此处为0. while (true) { System.out.println(&quot;请输入数据：&quot;); int number = sc.nextInt(); if (number != 0) { array.add(number); } else { break; } } // 把集合转成数组 // public &lt;T&gt; T[] toArray(T[] a) Integer[] i = new Integer[array.size()]; // Integer[] ii = array.toArray(i); array.toArray(i); // 对数组排序,public static void sort(Object[] a). Arrays.sort(i); // 获取该数组中的最大索引的值 System.out.println(&quot;数组是：&quot; + arrayToString(i) + &quot;,最大值是:&quot; + i[i.length - 1]); } public static String arrayToString(Integer[] i) { StringBuilder sb = new StringBuilder(); sb.append(&quot;[&quot;); for (int x = 0; x &lt; i.length; x++) { if (x == i.length - 1) { sb.append(i[x]); } else { sb.append(i[x]).append(&quot;, &quot;); } } sb.append(&quot;]&quot;); return sb.toString(); } ```]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>List 泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Common-List]]></title>
    <url>%2FGaoMing_18000211.github.io%2F2018%2F10%2F29%2FCommon-List%26%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[List list子类及其特性 ArrayList: 底层数据结构是数组，查询快，增删慢，线程不安全，效率高。 12345678910111213141516171819202122/*for example*/ public static void main(String[] args) &#123; ArrayList array = new ArrayList(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); Rem：1 // array.add(new Integer(100));// 标准写法 //array.add(10); // JDK5以后的自动装箱,等价于：array.add(Integer.valueOf(10)); Iterator it = array.iterator(); while (it.hasNext()) &#123; Rem：1，若使用Rem处代码，强转数据类型： // String s = (String) it.next(); 则： // ClassCastException String s = (String) it.next(); System.out.println(s); /*代码黄色警告线，因为事先不指定的数据类型，若添加的数据类型不一致，强转后抛出ClassCaseExcpetion异常，为隐患使用方法.*/ &#125; Vector: 底层数据结构是数组，查询快，增删慢，线程安全，效率低。 由于集合是JDK1.2后才有的特性，所以针对出现在JKD1.0的Vector本身有自己的添加获取功能，但是可以使用父类ArrayList对应功能所代替。 1234/*1.0版本的本身独有功能：*/添加：public void addElement(E obj) -- add()获取：public E elementAt(int index) -- get() public Enumeration&lt;E&gt; elements() -- iterator() 代码实例： 123456789101112131415161718192021222324252627282930313233 public static void main(String[] args) &#123; Vector v = new Vector(); v.addElement(&quot;hello&quot;); v.addElement(&quot;world&quot;); for (int x = 0; x &lt; v.size(); x++) &#123; String s = (String) v.elementAt(x); System.out.println(s); &#125; System.out.println(&quot;------------------&quot;); Enumeration en = v.elements(); while (en.hasMoreElements()) &#123; String s = (String) en.nextElement(); System.out.println(s); &#125; &#125; ``` - LinkedList: 底层数据结构是链表，查询慢，增删快，线程不安全，效率高。由于其有不同的底层结构所有也有特有函数。 ``` 添加： public void addFirst() //表头添加，头插法. public void addLast() //表尾添加，尾插法. 删除 public Object removeFirst() //删除第一个节点. public Object removeLast() //删除第二个节点. 获取 public Object getFirst() //获取第一个节点. public Object getLast() //获取最后一个节点. 代码实例 12345678910111213141516171819202122232425 public static void main(String[] args) &#123; LinkedList link = new LinkedList(); link.add(&quot;hello&quot;); //后面追加. link.add(&quot;world&quot;); // public void addFirst(Object e) // public void addLast(Object e) // public Object getFirst() // System.out.println(&quot;getFirst:&quot; + link.getFirst()); // public Obejct getLast() // System.out.println(&quot;getLast:&quot; + link.getLast()); // public Object removeFirst() System.out.println(&quot;removeFirst:&quot; + link.removeFirst()); // public Object removeLast() System.out.println(&quot;removeLast:&quot; + link.removeLast()); // 输出对象名，tostring(),返回对象内容。 System.out.println(&quot;link:&quot; + link); &#125; ``` - 总结 - 遍历字符串集合，仅保留重复元素的其中一个。 public static void main(String[] args) { // TODO Auto-generated method stub ArrayList arrayStr = new ArrayList(); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;luck&quot;); arrayStr.add(&quot;tom&quot;); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;Good&quot;); arrayStr.add(&quot;luck&quot;); arrayStr.add(&quot;tom&quot;); Iterator It = arrayStr.iterator(); ArrayList NewArrayStr = new ArrayList(); /* Method:the first */ while (It.hasNext()) { String temp = (String) It.next(); if (!(NewArrayStr.contains(temp))) { NewArrayStr.add(temp); } } System.out.println(&quot;Result:&quot; + NewArrayStr); System.out.println(&quot;******this is dividing line******&quot;); /* Method:the second */ for (int x = 0; x &lt; arrayStr.size() - 1; ++x) { for (int y = x + 1; y &lt; arrayStr.size(); ++y) { if (arrayStr.get(x).equals(arrayStr.get(y))) { arrayStr.remove(y); // 目的是为了解决相同元素，叠上来的时候造成数据漏检。 y--; } } } System.out.println(&quot;Result:&quot; + arrayStr); } 12 - 遍历对象集合，仅保留重复元素的其中一个。 package TestAa; import java.util.ArrayList; import java.util.Iterator; class Animal { private int age; private String name; public Animal() { super(); // TODO Auto-generated constructor stub } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Animal(String name, int age) { super(); this.age = age; this.name = name; } @Override public String toString() { // TODO Auto-generated method stub return this.getName() + &quot;:&quot; + this.getAge(); } // contain使用的是equal方法，所以需要重写equal方法。 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Animal other = (Animal) obj; if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } } public class CompareAa { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub ArrayList arrayList = new ArrayList(); Animal animal1 = new Animal(&quot;Tom&quot;, 3); Animal animal2 = new Animal(&quot;Jack&quot;, 5); Animal animal3 = new Animal(&quot;Tom&quot;, 2); Animal animal4 = new Animal(&quot;Tom&quot;, 3); Animal animal5 = new Animal(&quot;Jack&quot;, 5); Animal animal6 = new Animal(&quot;Tom&quot;, 2); Animal animal7 = new Animal(&quot;Tom&quot;, 2); Animal animal8 = new Animal(&quot;Jack&quot;, 5); Animal animal9 = new Animal(&quot;Tom&quot;, 2); arrayList.add(animal1); arrayList.add(animal2); arrayList.add(animal3); arrayList.add(animal4); arrayList.add(animal5); arrayList.add(animal6); arrayList.add(animal7); arrayList.add(animal8); arrayList.add(animal9); /* method:the first... */ Iterator it = arrayList.iterator(); ArrayList newArray = new ArrayList(); while (it.hasNext()) { Animal tempCc = (Animal) it.next(); if (!(newArray.contains(tempCc))) newArray.add(tempCc); } System.out.println(newArray); System.out.println(&quot;*****this is a dividing line******&quot;); /* method:the second... */ for (int x = 0; x &lt; arrayList.size() - 1; ++x) { for (int y = x + 1; y &lt; arrayList.size(); ++y) { if (arrayList.get(x).equals(arrayList.get(y))) { arrayList.remove(y); // 目的是为了解决相同元素漏检的问题。 y--; } } } System.out.println(arrayList); } } 12 - 用LinkedList模拟栈结构。 package TestAa; import java.util.LinkedList; class StackCc { private LinkedList linkCc; public StackCc() { linkCc = new LinkedList(); // TODO Auto-generated constructor stub } public Object popCc() { return linkCc.removeFirst(); } public void pushCc(Object obj) { linkCc.addFirst(obj); } @Override public String toString() { return &quot;StackCc [linkCc=&quot; + linkCc + &quot;]&quot;; } } public class CompareAa { /** * @param args */ public static void main(String[] args) { // TODO Auto-generated method stub StackCc Cc = new StackCc(); Cc.pushCc(&quot;hello&quot;); Cc.pushCc(&quot;world&quot;); System.out.println(Cc); System.out.println(&quot;******this is a dividing line******&quot;); Cc.popCc(); Cc.popCc(); System.out.println(Cc); } } 1234567891011### 泛型是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型，可以理解为一个程序的模版，在需要的时候才将所需要的数据类型填入其中，而在模版需要数据类型的位置需要添加一个占位标记符号&lt;&gt;，&lt;font size = 3, color = 0X6FFF&gt;该数据类型只能是引用类型&lt;/font&gt;。- 出现时间：JDK1.5- 特点： - 把运行时期的问题提前到了编译期间 - 避免了强制类型转换 - 优化了程序设计，解决了黄色警告线问题，让程序更安全，上诉的所有代码都有黄色警告，而使用泛型可以解决该问题，比如：已经确定ArrayList数据类型是String，防止list(new Integer(100))，导致下面强转时候报错。 - 安全性描述：早期的时候，我们使用Object来代表任意的类型，因为其为超类，是类的父类，但是实际使用的时候其实是限制了数据类型了，不能任意的转化，只能转化为本身，这就是存在的安全隐患，也就是警告提示的原因。 也就是说这样的程序其实并不是安全的。所以Java在JDK5后引入了泛型，提高程序的安全性。 - 代码实例 - 泛型&amp;String数据类型 /for example/ public static void main(String[] args) { //创建对象时候指定添加到数据类型就是String数据类型。 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); array.add(&quot;hello&quot;); array.add(&quot;world&quot;); Iterator&lt;String&gt; it = array.iterator(); while (it.hasNext()) { String s = it.next(); System.out.println(s); System.out.println(&quot;--------this is a dividing ling--------&quot;); for (String Cc : array) { System.out.println(Cc); } System.out.println(&quot;-------this is a dividing ling-------&quot;); for (int x = 0; x &lt; array.size(); ++x) { System.out.println(array.get(x)); } } / 泛型就是事先确定数据类型，不能具体确定的数据类型就使用占位符-通配符描述。/ 12- 泛型&amp;对象数据类型 /数据对象类型为对象类的遍历实现/ package TestAa; import java.util.ArrayList; import java.util.Iterator; class Animal { private String name; private int age; public Animal(String name, int age) { super(); this.name = name; this.age = age; } public Animal() { super(); // TODO Auto-generated constructor stub } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } public class CompareAa { /** * @param args */ public static void main(String[] args) { // JDK7的新特性：泛型推断。 // ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();不会报错也不会警告，但是不建议这样使用。 ArrayList&lt;Animal&gt; array = new ArrayList&lt;&gt;(); Animal s1 = new Animal(&quot;Tom&quot;, 4); Animal s2 = new Animal(&quot;Jack&quot;, 2); Animal s3 = new Animal(&quot;Coffe&quot;, 5); array.add(s1); array.add(s2); array.add(s3); Iterator&lt;Animal&gt; it = array.iterator(); while (it.hasNext()) { Animal s = it.next(); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } System.out.println(&quot;------this is a dividing line------&quot;); for (int x = 0; x &lt; array.size(); x++) { Animal s = array.get(x); System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } System.out.println(&quot;------this is a dividing line------&quot;); for (Animal s : array) { System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } } } 1234- 类别 - 泛型类 / for example/ /该段在编译时候不会报错也不会警告，但是运行错误，原因是类型转化问题/ public class ObjectTool { private Object obj; public Object getObj() { return obj; } public void setObj(Object obj) { // Object obj = new Integer(30); this.obj = obj; } } public class ObjectToolDemo { public static void main(String[] args) { ObjectTool ot = new ObjectTool(); // 运行正常。 ot.setObj(new Integer(2)); Integer i = (Integer) ot.getObj(); System.out.println(&quot;年龄是：&quot; + i); ot.setObj(new String(&quot;Tom&quot;)); String s = (String) ot.getObj(); System.out.println(&quot;姓名是：&quot; + s); System.out.println(&quot;---------&quot;); ot.setObj(new Integer(2)); // 报错，类型转换错误，ClassCastException String ss = (String) ot.getObj(); System.out.println(&quot;姓名是：&quot; + ss); } } System.out.println(“——-this is a dividing line———“); /泛型解决方案/ public class ObjectTool { private T obj; public T getObj() { return obj; } public void setObj(T obj) { this.obj = obj; } } public class ObjectToolDemo { public static void main(String[] args) { ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); ot.setObj(new String(&quot;Tom&quot;)); String s = ot.getObj(); System.out.println(&quot;姓名是：&quot; + s); ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); // ot2.setObj(new String(&quot;Jack&quot;));//这个时候编译期间就过不去 ot2.setObj(new Integer(27)); Integer i = ot2.getObj(); System.out.println(&quot;年龄是：&quot; + i); } } 12- 泛型方法 public class ObjectTool { public &lt;T&gt; void show(T t) { System.out.println(t); } } public class ObjectToolDemo { public static void main(String[] args) { // 定义到泛型方法后，可以接受任意数据类型。 ObjectTool ot = new ObjectTool(); ot.show(&quot;hello&quot;); ot.show(100); ot.show(true); } } 1- 泛型接口 public interface Inter { public abstract void show(T t); } /第一种：实现类在实现接口的时候已经知道数据类型/ public class InterImpl implements Inter { @Override public void show(String t) { System.out.println(t); } } //第二种情况：还不知道数据类型. public class InterImpl implements Inter { @Override public void show(T t) { System.out.println(t); } } public static void main(String[] args) { /*第一种*/ Inter&lt;String&gt; i = new InterImpl(); i.show(&quot;hello&quot;); /*第二种情况的测试*/ Inter&lt;String&gt; i = new InterImpl&lt;String&gt;(); i.show(&quot;hello&quot;); Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;(); ii.show(100); } 1234567- 泛型高级通配符 - ? - ? extends E - ? super E - 代码实例 /for example/ public class GenericDemo { public static void main(String[] args) { // 泛型如果明确的写的时候，前后必须一致 Collection&lt;Object&gt; c1 = new ArrayList&lt;Object&gt;(); // Collection&lt;Object&gt; c2 = new ArrayList&lt;Animal&gt;(); 报错 // ?表示任意的类型都是可以的 Collection&lt;?&gt; c5 = new ArrayList&lt;Object&gt;(); Collection&lt;?&gt; c6 = new ArrayList&lt;Animal&gt;(); // ? extends E:向下限定，E及其子类 // Collection&lt;? extends Animal&gt; c9 = new ArrayList&lt;Object&gt;(); Collection&lt;? extends Animal&gt; c10 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; c11 = new ArrayList&lt;Dog&gt;(); // ? super E:向上限定，E极其父类 Collection&lt;? super Animal&gt; c13 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; c14 = new ArrayList&lt;Animal&gt;(); // Collection&lt;? super Animal&gt; c15 = new ArrayList&lt;Dog&gt;(); } } class Animal { } class extends Dog{ } 12345 ### 增强for循环一种简化的for循环结构。- 格式 - for(DataType Variable : Collection/Object){ Variable in Array/Collection.} 123456789101112131415161718192021 ### 可变参数Arrays工具下一个函数：static &lt;T&gt; List&lt;T&gt; asList(T... a) 返回由指定数组支持的固定大小的列表。 - List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;); // UnsupportedOperationException // list.add(&quot;NewDay&quot;); // UnsupportedOperationException // list.remove(NewLife); list.set(1, &quot;Test&quot;); for (String s : list) &#123; System.out.println(s); &#125; &#125; ### 集合嵌套遍历- 实例一 /for example,二层嵌套/public class CollectionCc { public static void main(String[] args) { // 最外层集合 ArrayList&lt;ArrayList&lt;Animal&gt;&gt; bigArrayList = new ArrayList&lt;ArrayList&lt;Animal&gt;&gt;(); //创建对应的所有对象，分别添加进组，再小组进大组。 ArrayList&lt;Animal&gt; firstArrayList = new ArrayList&lt;Student&gt;(); bigArrayList.add(firstArrayList); ArrayList&lt;Animal&gt; secondArrayList = new ArrayList&lt;Student&gt;(); bigArrayList.add(secondArrayList); ArrayList&lt;Animal&gt; thirdArrayList = new ArrayList&lt;Student&gt;(); bigArrayList.add(thirdArrayList); // 遍历集合 for (ArrayList&lt;Animal&gt; array : bigArrayList) { for (Student s : array) { System.out.println(s.getName() + &quot;---&quot; + s.getAge()); } } }} 12- 实例二 /获取1-100随机数/public static void main(String[] args) { Random r = new Random(); //泛型集合 ArrayList&lt;Integer&gt; arrayCc = new ArrayList&lt;Integer&gt;(); int count = 0; while (count &lt; 10) { int number = r.nextInt(20) + 1; if(!arrayCc.contains(number)){ //如果不存在:就添加，统计变量++。 arrayCc.add(number); count++; } } //增强for遍历. for(Integer i : array){ System.out.println(i); } System.out.println(array); } 12- 实例三 /for example//获取键盘输入的不确定个数的最大值./public static void main(String[] args) { Scanner sc = new Scanner(System.in); // 数据不确定的情况下。只能是用集合存储，翻新保证程序的健壮性. ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // 设置结束符号，此处为0. while (true) { System.out.println(&quot;请输入数据：&quot;); int number = sc.nextInt(); if (number != 0) { array.add(number); } else { break; } } // 把集合转成数组 // public &lt;T&gt; T[] toArray(T[] a) Integer[] i = new Integer[array.size()]; // Integer[] ii = array.toArray(i); array.toArray(i); // 对数组排序,public static void sort(Object[] a). Arrays.sort(i); // 获取该数组中的最大索引的值 System.out.println(&quot;数组是：&quot; + arrayToString(i) + &quot;,最大值是:&quot; + i[i.length - 1]); } public static String arrayToString(Integer[] i) { StringBuilder sb = new StringBuilder(); sb.append(&quot;[&quot;); for (int x = 0; x &lt; i.length; x++) { if (x == i.length - 1) { sb.append(i[x]); } else { sb.append(i[x]).append(&quot;, &quot;); } } sb.append(&quot;]&quot;); return sb.toString(); } `]]></content>
      <categories>
        <category>Java基础学习</category>
      </categories>
      <tags>
        <tag>List 泛型</tag>
      </tags>
  </entry>
</search>
